
// --------------------------------------------------------------------------------
// Copyright (c) 2025 Igor Ryabov (https://github.com/IgorRyaboff/Instrumentiki)
// License: https://github.com/IgorRyaboff/Instrumentiki/blob/main/LICENSE
// --------------------------------------------------------------------------------

#Область ОписаниеПеременных

#КонецОбласти

#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	Элементы.ПривилегированныйРежим.Доступность = Не БезопасныйРежим();
	Элементы.Страницы.Видимость = Ложь;
	
	Элементы.Ссылка.ОграничениеТипа = ОграничениеТипаВсеСсылки();
	
	ПоказыватьРегистрыСведений = Истина;
	ПоказыватьРегистрыНакопления = Истина;
	ПоказыватьРегистрыБухгалтерии = Истина;
	ПоказыватьРегистрыРасчета = Истина;
	
	Если Параметры.Ссылка <> Неопределено Тогда
		Ссылка = Параметры.Ссылка;
		ПрочитатьОбъект();
	КонецЕсли;
	
	УМ_ПриСозданииНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	КлючУникальности = ?(ЗначениеЗаполнено(Ссылка), Ссылка, Неопределено);
	УМ_ПриОткрытии();
КонецПроцедуры

&НаКлиенте
Процедура ПередЗакрытием(Отказ, ЗавершениеРаботы, ТекстПредупреждения, СтандартнаяОбработка)
	Если Модифицированность И Не ЗавершениеРаботы Тогда
		ПередЗакрытиемАсинх();
		СтандартнаяОбработка = Ложь;
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	
	УМ_ПередЗакрытием(Отказ, ЗавершениеРаботы);
КонецПроцедуры

&НаКлиенте
Процедура ПриЗакрытии(ЗавершениеРаботы)
	УМ_ПриЗакрытии(ЗавершениеРаботы);
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы

#Область УниверсальныеМеханизмы1

#Область КрасивыйРедактор

// Обработчик ДокументСформирован HTML-документов красивого редактора
//  Подключается программно при вызове УМ_КрасивыйРедактор_ПриСозданииНаСервере
//
// Параметры:
//  Элемент - ПолеФормы - HTML-документ
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_СобытиеДокументСформирован(Элемент)
	Редактор = Неопределено;
	Для Каждого РедакторВнутриЦикла Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Если РедакторВнутриЦикла.ИмяЭлементаHTML = Элемент.Имя Тогда
			Редактор = РедакторВнутриЦикла;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Редактор = Неопределено Тогда
		Шаблон = НСтр("ru = 'Не найдено описание красивого редактора для элемента %1';
			|en = 'Did not found HTML editor description for form element %1'");
		ВызватьИсключение СтрШаблон(Шаблон, Элемент.Имя);
	КонецЕсли;
	
	Вью = _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элемент);
	Вью.setContent(ЭтотОбъект[Редактор.ИмяРеквизита]);
	Вью.setOption("generateModificationEvent", Истина);
	Вью.setOption("generateOnKeyDownEvent", Истина);
	Вью.updateMetadata(_УМ_КрасивыйРедактор_СтруктураМетаданных());
	
	// См. https://vk.cc/cs5MzW
	Если Редактор.Язык = "ВстроенныйЯзык" Тогда
		Вью.setLanguageMode("bsl");
	ИначеЕсли Редактор.Язык = "ЯзыкЗапросов" Тогда
		Вью.setLanguageMode("bsl_query");
	Иначе
		ВызватьИсключение НСтр("ru = 'Недопустимый язык редактора';
			|en = 'Invalid editor language'");
	КонецЕсли;
КонецПроцедуры

// Обработчик ПриНажатии HTML-документов красивого редактора
//  Подключается программно при вызове УМ_КрасивыйРедактор_ПриСозданииНаСервере
//
// Параметры:
//  Элемент - ПолеФормы - См. Синтакс-помощник
//  ДанныеСобытия - ФиксированнаяСтруктура - См. Синтакс-помощник
//  СтандартнаяОбработка - Булево - См. Синтакс-помощник
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_СобытиеПриНажатии(Элемент, ДанныеСобытия, СтандартнаяОбработка)
	СобытиеРедактора = ДанныеСобытия.Event.EventData1C;
	Если СобытиеРедактора = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Редактор = Неопределено;
	Для Каждого РедакторВнутриЦикла Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Если РедакторВнутриЦикла.ИмяЭлементаHTML = Элемент.Имя Тогда
			Редактор = РедакторВнутриЦикла;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Редактор = Неопределено Тогда
		Шаблон = НСтр("ru = 'Не найдено описание красивого редактора для элемента %1';
			|en = 'Did not found HTML editor description for form element %1'");
		ВызватьИсключение СтрШаблон(Шаблон, Элемент.Имя);
	КонецЕсли;
	
	Если СобытиеРедактора.event = "EVENT_CONTENT_CHANGED" Тогда
		НовыйТекст = _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элемент).getText();
		Если НовыйТекст <> ЭтотОбъект[Редактор.ИмяРеквизита] Тогда
			ЭтотОбъект[Редактор.ИмяРеквизита] = НовыйТекст;
			Модифицированность = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если СобытиеРедактора.event = "EVENT_ON_KEY_DOWN" Тогда
		Если СобытиеРедактора.params.keyCode = 9 Тогда // ESC
			Закрыть();
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры


#КонецОбласти

#КонецОбласти

&НаКлиенте
Процедура СсылкаПриИзменении(Элемент)
	ВызватьЧтениеОбъекта();
КонецПроцедуры

&НаКлиенте
Процедура ТекущаяТЧПриИзменении(Элемент)
	Элементы.СтраницыТЧ.ТекущаяСтраница = Элементы["Страница" + ТекущаяТЧ];
КонецПроцедуры

&НаКлиенте
Процедура ВыбранныйНаборДвиженийПриИзменении(Элемент)
	ИнициализироватьТаблицуТекущегоНабораДвижений();
КонецПроцедуры

&НаКлиенте
Процедура ПоказыватьПустыеТабличныеЧастиПриИзменении(Элемент)
	ОбновитьОтображаемыйСписокВыбораТабличныхЧастей(ЭтотОбъект);
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормыРеквизитыОбъекта

&НаКлиенте
Процедура РеквизитыОбъектаВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	СтрРеквизиты = Элемент.ТекущиеДанные;
	Если СтрРеквизиты = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Поле.Имя = "РеквизитыОбъектаИмяТипаЗначения" Тогда
		СтандартнаяОбработка = Ложь;
		ВыбратьТипЗначенияАсинх(СтрРеквизиты);
		Возврат;
	КонецЕсли;
	
	Если Поле.Имя = "РеквизитыОбъектаЗначение" И СтрРеквизиты.ТолькоПросмотр Тогда
		ПоказатьПредупреждение(, "Этот реквизит нельзя редактировать");
		СтандартнаяОбработка = Ложь;
		Возврат;
	КонецЕсли;
	
	Если Поле.Имя = "РеквизитыОбъектаЗначение" И ТипЗнч(СтрРеквизиты.Значение) = Тип("УникальныйИдентификатор") Тогда
		СтандартнаяОбработка = Ложь;
		ИзменитьУникальныйИдентификатор(СтрРеквизиты, "Значение");
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура РеквизитыОбъектаЗначениеПриИзменении(Элемент)
	ТекДанные = Элементы.РеквизитыОбъекта.ТекущиеДанные;
	Если ТекДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекДанные.ИмяТипаЗначения = ИмяТипаКакВКонфигураторе(ТипЗнч(ТекДанные.Значение));
	ТекДанные.ИмяЗначения = ИмяЗначения(ТекДанные.Значение);
	ТекДанные.Изменено = (ТекДанные.Значение <> ТекДанные.ПервоначальноеЗначение);
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормыТекущийНаборДвижений

&НаКлиенте
Процедура ТекущийНаборДвиженийВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	Если Не Элемент.ТолькоПросмотр Тогда
		Возврат;
	КонецЕсли;
	
	ТекДанные = Элемент.ТекущиеДанные;
	Если ТекДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ИмяКолонки = СтрЗаменить(ПутьКДаннымЭлементаФормы(Элемент.ТекущийЭлемент.Имя), "ТекущийНаборДвижений.", "");
	ПоказатьЗначение(, ТекДанные[ИмяКолонки]);
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицФормыТабличныхЧастей

&НаКлиенте
Процедура ТабличнаяЧастьПриИзменении(Элемент)
	ОбновитьОтображаемыйСписокВыбораТабличныхЧастей(ЭтотОбъект);
КонецПроцедуры

&НаКлиенте
Процедура ТабличнаяЧастьВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	СтрТабличнойЧасти = Элемент.ТекущиеДанные;
	
	СоставПутиКДанным = ПутьКДаннымЭлементаФормы(Поле.Имя);
	ИмяРеквизита = СтрРазделить(СоставПутиКДанным, ".")[1];
	
	ТекущееЗначение = СтрТабличнойЧасти[ИмяРеквизита];
	Если ТипЗнч(ТекущееЗначение) = Тип("УникальныйИдентификатор") Тогда
		СтандартнаяОбработка = Ложь;
		ИзменитьУникальныйИдентификатор(СтрТабличнойЧасти, ИмяРеквизита);
		Возврат;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

#Область УниверсальныеМеханизмы1

#Область Сохранение

// Обработчик команды открытия сохраненного файла
//
// Параметры:
//  Команда - КомандаФормы - Вызванная команда
//
&НаКлиенте
Асинх Процедура УМ_Сохранение_ОткрытьФайл(Команда)
	Если Не Ждать УМ_Сохранение_ЗапроситьСохранениеАсинх() Тогда
		Возврат;
	КонецЕсли;
	
	АдресВХ = Неопределено;
	Если ЗначениеЗаполнено(ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения) Тогда
		Кнопки = Новый СписокЗначений;
		Кнопки.Добавить(КодВозвратаДиалога.Да, НСтр("ru = 'Открыть сохраненные данные';
			|en = 'Open previously saved data'"));
		Кнопки.Добавить(КодВозвратаДиалога.Нет, НСтр("ru = 'Открыть данные из файла...';
			|en = 'Open a file...'"));
		Кнопки.Добавить(КодВозвратаДиалога.Отмена);
		Ответ = Ждать ВопросАсинх(НСтр("ru = 'Есть сохраненные данные с прошлого сеанса использования инструмента';
			|en = 'There are autosaved data from previous tool usage'"), Кнопки);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			АдресВХ = ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения;
		ИначеЕсли Ответ = КодВозвратаДиалога.Нет Тогда
			ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения = Неопределено;
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(АдресВХ) Тогда
		ПараметрыДиалогаПомещенияФайлов = Новый ПараметрыДиалогаПомещенияФайлов;
		ПараметрыДиалогаПомещенияФайлов.МножественныйВыбор = Ложь;
		ПараметрыДиалогаПомещенияФайлов.Фильтр = НСтр("ru = 'Сохранённые данные Инструментиков (*.xml)|*.xml|Все файлы|*';
			|en = 'Instrumentiki saved data (*.xml)|*.xml|All files|*'");
		
		ОписаниеПомещенногоФайла = Ждать ПоместитьФайлНаСерверАсинх(,,,
			ПараметрыДиалогаПомещенияФайлов, ЭтотОбъект.УникальныйИдентификатор);
		//
		Если ОписаниеПомещенногоФайла = Неопределено Тогда
			Возврат;
		КонецЕсли;
		АдресВХ = ОписаниеПомещенногоФайла.Адрес;
	КонецЕсли;
	
	УМ_Сохранение_ПрочитатьУниверсальныйПакет(АдресВХ);
	УМ_Сохранение_ПослеЧтенияУниверсальногоПакетаПереопределяемый();
КонецПроцедуры

// Обработчик команды сохранения данных инструмента в файл
//
// Параметры:
//  Команда - КомандаФормы - Вызванная команда
//
&НаКлиенте
Процедура УМ_Сохранение_СохранитьФайл(Команда)
	УМ_Сохранение_СохранитьАсинх();
КонецПроцедуры

#КонецОбласти

#КонецОбласти

&НаКлиенте
Процедура ОчиститьЗначениеРеквизита(Команда)
	ТекДанные = Элементы.РеквизитыОбъекта.ТекущиеДанные;
	Если ТекДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекДанные.Значение = Неопределено;
	ТекДанные.Изменено = Истина;
	Модифицированность = Ложь;
КонецПроцедуры

&НаКлиенте
Асинх Процедура Записать(Команда)
	Если Ссылка.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьНаСервере("Запись");
КонецПроцедуры

&НаКлиенте
Асинх Процедура Перечитать(Команда)
	Если Не (Ждать ЗапроситьСохранениеАсинх()) Тогда
		Возврат;
	КонецЕсли;
	ВызватьЧтениеОбъекта();
КонецПроцедуры

&НаКлиенте
Асинх Процедура УдалитьНепосредственно(Команда)
	Ответ = Ждать ВопросАсинх("Непосредственное удаление объектов может сделать базу неработоспособной. Вы точно понимаете, что делаете?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Нет);
	Если Ответ = КодВозвратаДиалога.Нет Тогда
		Возврат;
	КонецЕсли;
	
	Ответ = Ждать ВопросАсинх("Вы собираетесь физически удалить объект. Подумайте ещё раз", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Нет);
	Если Ответ = КодВозвратаДиалога.Нет Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ОбъектСуществует(Ссылка) Тогда
		Сообщить("Объект и так не существует");
	Иначе
		УдалитьНепосредственноНаСервере(Ссылка, ПривилегированныйРежим, ОбменДаннымиЗагрузка);
	КонецЕсли;
	
	Ссылка = Новый(ТипЗнч(Ссылка));
	ВызватьЧтениеОбъекта();
КонецПроцедуры

&НаКлиенте
Асинх Процедура ПолучитьОбъектИзНавигационнойСсылки(Команда)
	НоваяСсылка = Ждать УМ_ПолучениеСсылок_ЗапроситьСсылкуИзНавигационнойАсинх();
	Если НоваяСсылка <> Неопределено Тогда
		Ссылка = НоваяСсылка;
		ВызватьЧтениеОбъекта();
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Асинх Процедура ЗаписатьДвижения(Команда)
	ЗаписатьДвиженияНаСервере();
	ПоказатьПредупреждение(, "Движения по данному регистру успешно записаны");
КонецПроцедуры

&НаКлиенте
Асинх Процедура ПроанализироватьИзмененияВДвижениях(Команда)
	Ответ = Ждать ВопросАсинх("Во время анализа движений документ будет временно перепроведён. Анализ может занять вплоть до нескольких минут. Продолжить?", РежимДиалогаВопрос.ДаНет);
	Если Ответ = КодВозвратаДиалога.Нет Тогда
		Возврат;
	КонецЕсли;
	
	Если Не Модифицированность Тогда
		Ответ = Ждать ВопросАсинх("В документе нет изменений. Продолжить?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ОбъектСуществует(Ссылка) Тогда
		ПоказатьПредупреждение(, "Объект не существует");
		Возврат;
	КонецЕсли;
	
	Состояние("Анализируем изменения в движениях...");
	ТаблДок = ПроанализироватьИзмененияВДвиженияхНаСервере();
	
	Состояние("Анализ окончен!");
	Если ТаблДок = Неопределено Тогда
		ПоказатьПредупреждение(, "Изменений в движениях не произошло");
		Возврат;
	КонецЕсли;
	ТаблДок.Показать();
КонецПроцедуры

&НаКлиенте
Асинх Процедура ПолучитьОбъектИзОткрытогоОкна(Команда)
	НоваяСсылка = Ждать УМ_ПолучениеСсылок_ЗапроситьСсылкуИзОткрытыхОконАсинх();
	Если НоваяСсылка <> Неопределено Тогда
		Ссылка = НоваяСсылка;
		ВызватьЧтениеОбъекта();
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПрочитатьДвижения(Команда)
	ЗаполнитьДвижения();
	Элементы.ПрочитатьДвижения.Видимость = Ложь;
КонецПроцедуры

&НаКлиенте
Процедура РедактироватьЗначениеВКонсолиКода(Команда)
	ТекДанные = Элементы.РеквизитыОбъекта.ТекущиеДанные;
	Если ТекДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЭтоХранилищеЗначения = (ТипЗнч(ТекДанные.Значение) = Тип("ХранилищеЗначения"));
	
	ШаблонКода = "Менеджер = Новый(""%1"");
	             |Объект = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(""%5"")).ПолучитьОбъект();
	             |Значение = Объект.%2;
				 |
				 |// Обработка значения
				 |
				 |Объект.%3 = %4;
				 |Объект.Записать();";
	ИмяМенеджера = ИмяМенеджераПоПолномуИмениОбъектаМетаданных(ПолноеИмяОбъектаМетаданных);
	Код = СтрШаблон(ШаблонКода, ИмяМенеджера, ?(ЭтоХранилищеЗначения, ТекДанные.Имя + ".Получить()", ТекДанные.Имя), ТекДанные.Имя, ?(ЭтоХранилищеЗначения, "Новый ХранилищеЗначения(Значение)", "Значение"), Ссылка.УникальныйИдентификатор());
	
	ПараметрыФормы = Новый Структура("Код, НаКлиенте", Код, Ложь);
	ОткрытьФорму(Объект.ИмяМетаданныхОбработки + ".Форма.КонсольКода", ПараметрыФормы);
КонецПроцедуры

&НаКлиенте
Процедура СортироватьРеквизитыПоВозрастанию(Команда)
	СортироватьТаблицуЗначений("РеквизитыОбъекта", "Возр");
КонецПроцедуры

&НаКлиенте
Процедура СортироватьРеквизитыПоУбыванию(Команда)
	СортироватьТаблицуЗначений("РеквизитыОбъекта", "Убыв");
КонецПроцедуры

&НаКлиенте
Процедура ОтобратьРеквизитыТолькоЗаполненные(Команда)
	ОтборРеквизитовТолькоЗаполненные = Не ОтборРеквизитовТолькоЗаполненные;
	УстановитьОтборРеквизитов();
КонецПроцедуры

&НаКлиенте
Процедура ОтобратьРеквизитыТолькоТребующиеЗаполнения(Команда)
	ОтборРеквизитовТолькоТребущиеЗаполнения = Не ОтборРеквизитовТолькоТребущиеЗаполнения;
	УстановитьОтборРеквизитов();
КонецПроцедуры

&НаКлиенте
Процедура ПереключитьОтображениеРегистровСведенийВДвижениях(Команда)
	ПоказыватьРегистрыСведений = Не ПоказыватьРегистрыСведений;
	Элементы.ПереключитьОтображениеРегистровСведенийВДвижениях.Пометка = ПоказыватьРегистрыСведений;
	
	ЗаполнитьСписокВыбораНабораДвижений();
КонецПроцедуры

&НаКлиенте
Процедура ПереключитьОтображениеРегистровНакопленийВДвижениях(Команда)
	ПоказыватьРегистрыНакопления = Не ПоказыватьРегистрыНакопления;
	Элементы.ПереключитьОтображениеРегистровНакопленийВДвижениях.Пометка = ПоказыватьРегистрыНакопления;
	
	ЗаполнитьСписокВыбораНабораДвижений();
КонецПроцедуры

&НаКлиенте
Процедура ПереключитьОтображениеРегистровБухгалтерииВДвижениях(Команда)
	ПоказыватьРегистрыБухгалтерии = Не ПоказыватьРегистрыБухгалтерии;
	Элементы.ПереключитьОтображениеРегистровБухгалтерииВДвижениях.Пометка = ПоказыватьРегистрыБухгалтерии;
	
	ЗаполнитьСписокВыбораНабораДвижений();
КонецПроцедуры

&НаКлиенте
Процедура ПереключитьОтображениеРегистровРасчетаВДвижениях(Команда)
	ПоказыватьРегистрыРасчета = Не ПоказыватьРегистрыРасчета;
	Элементы.ПереключитьОтображениеРегистровРасчетаВДвижениях.Пометка = ПоказыватьРегистрыРасчета;
	
	ЗаполнитьСписокВыбораНабораДвижений();
КонецПроцедуры

&НаКлиенте
Процедура ПереключитьОтображениеПустыхНаборовДвижений(Команда)
	ПоказыватьПустыеРегистрыДвижений = Не ПоказыватьПустыеРегистрыДвижений;
	Элементы.ПереключитьОтображениеПустыхНаборовДвижений.Пометка = ПоказыватьПустыеРегистрыДвижений;
	
	ЗаполнитьСписокВыбораНабораДвижений();
КонецПроцедуры

&НаКлиенте
Процедура ПровестиДокумент(Команда)
	Если Ссылка.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьНаСервере("Проведение");
КонецПроцедуры

&НаКлиенте
Процедура ОтменитьПроведениеДокумента(Команда)
	Если Ссылка.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьНаСервере("ОтменаПроведения");
КонецПроцедуры

&НаКлиенте
Процедура ОткрытьРеквизитШапкиВРедакторе(Команда)
	ТекДанные = Элементы.РеквизитыОбъекта.ТекущиеДанные;
	Если ТекДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ОткрытьРеквизитВРедактореАсинх(ТекДанные.Значение);
КонецПроцедуры

&НаКлиенте
Процедура ОткрытьРеквизитТЧВРедакторе(Команда)
	ТаблицаФормы = Элементы["ТЧ_" + ТекущаяТЧ];
	ТекДанные = ТаблицаФормы.ТекущиеДанные;
	Если ТекДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Значение = ТекДанные[СтрЗаменить(ТаблицаФормы.ТекущийЭлемент.Имя, "ТЧ_" + ТекущаяТЧ + "_", "")];
	ОткрытьРеквизитВРедактореАсинх(Значение);
КонецПроцедуры

&НаКлиенте
Асинх Процедура ОткрытьСписокПоследнихОбъектов(Команда)
	Список = Новый СписокЗначений;
	Список.ЗагрузитьЗначения(ИсторияРедактора());
	Если Список.Количество() = 0 Тогда
		ПоказатьПредупреждение(, "Исторяи редактора пуста");
		Возврат;
	КонецЕсли;
	
	ВыбранныйЭлемент = Ждать Список.ВыбратьЭлементАсинх();
	Если ВыбранныйЭлемент = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Не Ждать ЗапроситьСохранениеАсинх() Тогда
		Возврат;
	КонецЕсли;
	
	Ссылка = ВыбранныйЭлемент.Значение;
	ВызватьЧтениеОбъекта();
КонецПроцедуры

&НаКлиенте
Асинх Процедура ОткрытьОбъектПоУникальномуИдентификатору(Команда)
	Если ТипЗнч(Ссылка) = Тип("Неопределено") Тогда
		Ответ = Ждать ВопросАсинх(НСтр("ru='Тип объекта не выбран. Выполнить поиск ссылки по всем таблицам БД ссылочных типов?'"), РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ИдентификаторСтрокой = Ждать ВвестиСтрокуАсинх("", "Введите GUID");
	Если ИдентификаторСтрокой = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		Идентификатор = Новый УникальныйИдентификатор(ИдентификаторСтрокой);
	Исключение
		ПоказатьПредупреждение(, "Введенное значение не является уникальным идентификатором");
		Возврат;
	КонецПопытки;
	
	НайденнаяСсылка = СсылкаПоУникальномуИдентификатору(Ссылка, Идентификатор);
	Если НайденнаяСсылка = Неопределено Тогда
		ПоказатьПредупреждение(, НСтр("ru='Не удалось найти ссылку. Если вам известен тип объекта, откройте любой объект этого типа, а затем повторите попытку поиска по GUID'"));
		Возврат;
	КонецЕсли;
	
	Ссылка = НайденнаяСсылка;
	ВызватьЧтениеОбъекта();
КонецПроцедуры

&НаКлиенте
Процедура ПереключитьРедактрованиеДвижений(Команда)
	Элементы.ТекущийНаборДвижений.ТолькоПросмотр = Не Элементы.ТекущийНаборДвижений.ТолькоПросмотр;
	Элементы.ТекущийНаборДвиженийПереключитьРедактрованиеДвижений.Пометка = Не Элементы.ТекущийНаборДвижений.ТолькоПросмотр;
КонецПроцедуры

&НаКлиенте
Асинх Процедура ВыбратьОбъектИзПримитивнойФормыВыбора(Команда)
	Если Ссылка = Неопределено Тогда
		ПоказатьПредупреждение(, НСтр("ru='Необходимо предварительно открыть любой объект нужного типа'"));
		Возврат;
	КонецЕсли;
	
	ПараметрыФормы = Новый Структура("ОпорнаяСсылка", Ссылка);
	ОповещениеОЗакрытии = Новый ОписаниеОповещения("ПослеВыбораОбъектаИзПримитивнойФормы", ЭтотОбъект);
	ОткрытьФорму(Объект.ИмяМетаданныхОбработки + ".Форма.РедакторОбъектов_ФормаВыбора", ПараметрыФормы,,,,, ОповещениеОЗакрытии);
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область УниверсальныеМеханизмы1

#Область ОбработчикиСобытийФормы

// Необходимо вызывать внутри обработчика ПриСозданииНаСервере модуля формы
//
&НаСервере
Процедура УМ_ПриСозданииНаСервере()
	Реквизит = Новый РеквизитФормы("УМ_Данные", Новый ОписаниеТипов);
	ДобавляемыеРеквизиты = Новый Массив;
	ДобавляемыеРеквизиты.Добавить(Реквизит);
	ИзменитьРеквизиты(ДобавляемыеРеквизиты);
	ЭтотОбъект.УМ_Данные = Новый Структура;
КонецПроцедуры

// Необходимо вызывать внутри обработчика ПриОткрытии модуля формы
//
&НаКлиенте
Процедура УМ_ПриОткрытии()
	_УМ_КрасивыйРедактор_ПриОткрытии();
КонецПроцедуры

// Необходимо вызывать внутри обработчика ПередЗакрытием модуля формы
//
// Параметры:
//  Отказ - Булево - Параметр из обработчика события формы
//  ЗавершениеРаботы - Булево - Параметр из обработчика события формы
//
&НаКлиенте
Процедура УМ_ПередЗакрытием(Отказ, ЗавершениеРаботы)
	_УМ_Сохранение_ПередЗакрытием(Отказ, ЗавершениеРаботы);
КонецПроцедуры

// Необходимо вызывать внутри обработчика ПриЗакрытии модуля формы
//
// Параметры:
//  ЗавершениеРаботы - Булево - Параметр из обработчика события формы
//
&НаКлиенте
Процедура УМ_ПриЗакрытии(ЗавершениеРаботы)
	_УМ_КрасивыйРедактор_ПриЗакрытии(ЗавершениеРаботы);
КонецПроцедуры

#КонецОбласти

#Область Сохранение

// Необходимо вызывать внутри обработчика ПриСозданииНаСервере модуля формы при использовании механизма "Сохранение"
// Вызов должен размещаться после вызова УМ_ПриСозданииНаСервере
//
&НаСервере
Процедура УМ_Сохранение_ПриСозданииНаСервере()
	ЭтотОбъект.УМ_Данные.Вставить("Сохранение", Новый Структура);
	
	КлючНастроек = "";
	ИмяОбъекта = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(Неопределено, ИмяОбъекта, Неопределено, КлючНастроек);
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	СохраненныеДанные = МодульОбъекта.СохраненнаяНастройка(КлючНастроек, "ДанныеАвтосохранения");
	
	ЭтотОбъект.УМ_Данные.Сохранение.Вставить("АдресДанныхАвтосохранения");
	Если ЗначениеЗаполнено(СохраненныеДанные) Тогда
		АдресВХ = ПоместитьВоВременноеХранилище(СохраненныеДанные, УникальныйИдентификатор);
		
		МодульОбъекта = РеквизитФормыВЗначение("Объект");
		РезультатЧтения = МодульОбъекта.ДанныеИзУниверсальногоПакетаВХ(АдресВХ, ИмяОбъекта);
		
		Если Не РезультатЧтения.Свойство("Ошибка") Тогда
			ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения = АдресВХ;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Загружает данные, ранее сохранённые в этом инструменте
//
// Параметры:
//  Адрес - Строка - Адрес файла во временном хранилище
//
&НаСервере
Процедура УМ_Сохранение_ПрочитатьУниверсальныйПакет(Знач Адрес)
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	
	ВерсияФормата = 0;
	ИмяИнструмента = "";
	ИмяОбъекта = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(ВерсияФормата, ИмяОбъекта,
		ИмяИнструмента, Неопределено);
	//
	
	ДанныеПакета = МодульОбъекта.ДанныеИзУниверсальногоПакетаВХ(Адрес, ИмяОбъекта);
	Если ДанныеПакета.Свойство("Ошибка") Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ДанныеПакета.Ошибка;
		Сообщение.Сообщить();
		Возврат;
	КонецЕсли;
	
	УМ_Сохранение_ПриЧтенииОбъектаПереопределяемый(ДанныеПакета.Объект, ДанныеПакета.ВерсияФормата);
	
	Модифицированность = Ложь;
КонецПроцедуры

// Выполняет автосохранение данных формы
//
&НаСервере
Процедура УМ_Сохранение_ВыполнитьАвтосохранение()
	КлючНастроек = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(Неопределено, Неопределено,
		Неопределено, КлючНастроек);
	//
	
	АдресПакетаВХ = _УМ_Сохранение_СформироватьУниверсальныйПакет();
	ДанныеПакета = ПолучитьИзВременногоХранилища(АдресПакетаВХ);
	УдалитьИзВременногоХранилища(АдресПакетаВХ);
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	МодульОбъекта.СохранитьНастройку(ключНастроек, "ДанныеАвтосохранения", ДанныеПакета);
	ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения = Неопределено;
КонецПроцедуры

// Запрашивает сохранение текущих данных
//
// Параметры:
//  ЗакрытьФорму - Булево - Если Истина, форма будет закрыта после сохранения или отказа от сохранения
//
// Возвращаемое значение:
//  Обещание - Результат работы обещания - Булево - Разрешить выполнение действия
//
&НаКлиенте
Асинх Функция УМ_Сохранение_ЗапроситьСохранениеАсинх(ЗакрытьФорму = Ложь)
	Если Не Модифицированность Тогда
		Возврат Истина;
	КонецЕсли;
	
	Ответ = Ждать ВопросАсинх("Данные были изменены. Сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
	Если Ответ = КодВозвратаДиалога.Да Тогда
		Результат = Ждать УМ_Сохранение_СохранитьАсинх();
	ИначеЕсли Ответ = КодВозвратаДиалога.Нет Тогда
		Результат = Истина;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	
	Если Результат И ЗакрытьФорму Тогда
		Модифицированность = Ложь;
		ЭтотОбъект.Закрыть();
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Выполняет сохранение данных
//
// Возвращаемое значение:
//  Обещание - Результат работы обещания - Булево - Данные сохранены
//             Может быть Ложь, если пользователь отменил сохранение в соответствующих диалогах
//
&НаКлиенте
Асинх Функция УМ_Сохранение_СохранитьАсинх()
	ИмяИнструмента = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(Неопределено, Неопределено,
		ИмяИнструмента, Неопределено);
	//
	
	Если Не ПроверитьЗаполнение() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		АдресВХ = _УМ_Сохранение_СформироватьУниверсальныйПакет();
		#Если ВебКлиент Тогда
			Ждать ПолучитьФайлССервераАсинх(АдресВХ, ИмяИнструмента + ".xml", Новый ПараметрыДиалогаПолученияФайлов);
		#Иначе
			Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
			Диалог.Фильтр = "Файл сохраняемых данных (*.xml)|*.xml|Все файлы|*";
			ВыбранныеФайлы = Ждать Диалог.ВыбратьАсинх();
			Если ВыбранныеФайлы = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Ждать ПолучитьФайлССервераАсинх(АдресВХ, ВыбранныеФайлы[0]);
		#КонецЕсли
	Исключение
		ТекстОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Ждать ПредупреждениеАсинх(ТекстОшибки,, НСтр("ru='Ошибка сохранения данных'"));
	КонецПопытки;
	
	Модифицированность = Ложь;
	Возврат Истина;
КонецФункции

// Формирует XML-файл для сохранения текущих данных и помещает его во временное хранилище
//
// Возвращаемое значение:
//  Строка - Адрес во временном хранилище
//
&НаСервере
Функция _УМ_Сохранение_СформироватьУниверсальныйПакет()
	ВерсияФормата = 0;
	ИмяИнструмента = "";
	ИмяОбъекта = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(ВерсияФормата, ИмяОбъекта,
		ИмяИнструмента, Неопределено);
	//
	Если ВерсияФормата = 0 Тогда
		ВызватьИсключение "Не определены настройки инструмента XDTO";
	КонецЕсли;
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	Фабрика = МодульОбъекта.ФабрикаXDTO(ВерсияФормата);
	
	ОбъектXDTO = Фабрика.Создать(Фабрика.Тип("instrumentiki", ИмяОбъекта));
	УМ_Сохранение_ПриЗаполненииСохраняемогоОбъектаПереопределяемый(Фабрика, ОбъектXDTO);
	ОбъектXDTO.Проверить();
	
	АдресВХ = МодульОбъекта.ДанныеВУниверсальныйПакетВХ(ВерсияФормата, ОбъектXDTO,
		ИмяИнструмента, ЭтотОбъект.УникальныйИдентификатор);
	//
	Возврат АдресВХ;
КонецФункции

&НаКлиенте
Процедура _УМ_Сохранение_ПередЗакрытием(Отказ, ЗавершениеРаботы)
	Если Не ЭтотОбъект.УМ_Данные.Свойство("Сохранение") Тогда
		Возврат;
	КонецЕсли;
	
	Если Модифицированность Тогда
		Отказ = Истина;
		Если Не ЗавершениеРаботы Тогда
			УМ_Сохранение_ЗапроситьСохранениеАсинх(Истина);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область КрасивыйРедактор

// Необходимо вызывать внутри обработчика ПриСозданииНаСервере модуля формы при использовании
// механизма "КрасивыйРедактор"
// Вызов должен размещаться после вызова УМ_ПриСозданииНаСервере
//
&НаСервере
Процедура УМ_КрасивыйРедактор_ПриСозданииНаСервере()
	ЭтотОбъект.УМ_Данные.Вставить("КрасивыйРедактор", Новый Структура);
	ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Вставить("Используется", Ложь);
	
	Редакторы = Новый Массив;
	УМ_КрасивыйРедактор_ПриОпределенииРедакторовПереопределяемый(Редакторы);
	ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Вставить("Редакторы", Редакторы);
	
	Для Каждого Редактор Из Редакторы Цикл
		Элементы[Редактор.ИмяЭлементаТекстовыйДокумент].Видимость = Истина;
		Элементы[Редактор.ИмяЭлементаHTML].Видимость = Ложь;
		
		Элементы[Редактор.ИмяЭлементаHTML].УстановитьДействие(
			"ДокументСформирован", "УМ_КрасивыйРедактор_СобытиеДокументСформирован");
		Элементы[Редактор.ИмяЭлементаHTML].УстановитьДействие(
			"ПриНажатии", "УМ_КрасивыйРедактор_СобытиеПриНажатии");
	КонецЦикла;
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	МодульОбъекта.ИнициализироватьКрасивыйРедакторКода(УникальныйИдентификатор);
	ЗначениеВРеквизитФормы(МодульОбъекта, "Объект");
КонецПроцедуры

// Переключает редактор кода между текстовым документом и HTML-редактором
//
// Параметры:
//  Кнопка - КнопкаФормы - Кнопка, на которой необходимо отразить новое состояние использования красивого редактора
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_ПереключитьРедакторКода(Кнопка)
	#Если ВебКлиент Тогда
		ПоказатьПредупреждение(, "Красивый редактор кода недоступен в веб-клиенте",, "Ой, у вас веб-клиент");
		Возврат;
	#КонецЕсли
	
	ИспользуетсяКрасивыйРедактор = Не ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Используется;
	ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Используется = ИспользуетсяКрасивыйРедактор;
	
	Для Каждого Редактор Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Элементы[Редактор.ИмяЭлементаТекстовыйДокумент].Видимость = Не ИспользуетсяКрасивыйРедактор;
		Элементы[Редактор.ИмяЭлементаHTML].Видимость = ИспользуетсяКрасивыйРедактор;
		Кнопка.Пометка = ИспользуетсяКрасивыйРедактор;
	КонецЦикла;
КонецПроцедуры

// Обновляет код в HTML-полях красивого редактора
// Может вызываться при программном изменении значения исходного реквизита с кодом
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_ОбновитьТекст()
	Для Каждого Редактор Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Вью = _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элементы[Редактор.ИмяЭлементаHTML]);
		Если Вью <> Неопределено Тогда
			Вью.setContent(ЭтотОбъект[Редактор.ИмяРеквизита]);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Функция _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элемент)
	Возврат ?(Элемент.Документ = Неопределено, Неопределено, Элемент.Документ.defaultView);
КонецФункции

&НаКлиенте
Процедура _УМ_КрасивыйРедактор_ПриОткрытии()
	Если Не ЭтотОбъект.УМ_Данные.Свойство("КрасивыйРедактор") Тогда
		Возврат;
	КонецЕсли;
	
	#Если Не ВебКлиент Тогда
		Если ЭтоАдресВременногоХранилища(Объект.ПутьККрасивомуРедакторуКода) Тогда
			_УМ_КрасивыйРедактор_РаспаковатьРедактор();
		Иначе
			ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь = Объект.ПутьККрасивомуРедакторуКода;
		КонецЕсли;
	#КонецЕсли
КонецПроцедуры

// Получает ZIP-файл из временного хранилища и распаковывает архив во временную директорию
//
&НаКлиенте
Асинх Процедура _УМ_КрасивыйРедактор_РаспаковатьРедактор()
	// BSLLS:MissingTemporaryFileDeletion-off
	// Каталог нужен на весь период, пока открыта форма. Удаляется в обработчике ПриЗакрытии
	Каталог = ПолучитьИмяВременногоФайла() + "\";
	// BSLLS:MissingTemporaryFileDeletion-on
	ПутьКАрхиву = Каталог + "archive.zip";
	
	Ждать СоздатьКаталогАсинх(Каталог);
	Ждать ПолучитьФайлССервераАсинх(Объект.ПутьККрасивомуРедакторуКода, ПутьКАрхиву);
	
	ЧтениеZIP = Новый ЧтениеZipФайла(ПутьКАрхиву);
	ЧтениеZIP.ИзвлечьВсе(Каталог);
	ЧтениеZIP.Закрыть();
	Ждать УдалитьФайлыАсинх(ПутьКАрхиву);
	
	ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь = "file://" + СтрЗаменить(Каталог, "\", "/") + "index.html";
КонецПроцедуры

// См. https://github.com/salexdv/bsl_console/blob/develop/docs/update_metadata.md
//
// Возвращаемое значение:
//  Структура
//
&НаСервереБезКонтекста
Функция _УМ_КрасивыйРедактор_СтруктураМетаданных()
	Результат = Новый Структура;
	
	Результат.Вставить("catalogs",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Справочники));
	//
	Результат.Вставить("documents",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Документы));
	//
	Результат.Вставить("informationregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыСведений));
	//
	Результат.Вставить("accumulationregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыНакопления));
	//
	Результат.Вставить("accountingregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыБухгалтерии));
	//
	Результат.Вставить("calculationregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыРасчета));
	//
	Результат.Вставить("dataprocessors",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Обработки));
	//
	Результат.Вставить("reports",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Отчеты));
	//
	Результат.Вставить("enums",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Перечисления));
	//
	Результат.Вставить("chartsofaccounts",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыСчетов));
	//
	Результат.Вставить("businessprocesses",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.БизнесПроцессы));
	//
	Результат.Вставить("tasks",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Задачи));
	//
	Результат.Вставить("exchangeplans",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыОбмена));
	//
	Результат.Вставить("chartsofcharacteristictypes",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыВидовХарактеристик));
	//
	Результат.Вставить("chartsofcalculationtypes",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыВидовРасчета));
	//
	Результат.Вставить("constants",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Константы));
	//
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, Результат);
	
	Возврат Запись.Закрыть();
КонецФункции

// Формирует структуру с именами метаданных для красивого редактора кода
// См. https://github.com/salexdv/bsl_console/blob/develop/docs/update_metadata.md
//
// Параметры:
//  КоллекцияОбъектовМетаданных - КоллекцияОбъектовМетаданных - Коллекция объектов метаданных
//
// Возвращаемое значение:
//  Структура
//
&НаСервереБезКонтекста
Функция _УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(КоллекцияОбъектовМетаданных)
	Результат = Новый Структура;
	
	Для Каждого Мета Из КоллекцияОбъектовМетаданных Цикл
		Результат.Вставить(Мета.Имя, Новый Структура);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Процедура _УМ_КрасивыйРедактор_ПриЗакрытии(ЗавершениеРаботы)
	Если Не ЭтотОбъект.УМ_Данные.Свойство("КрасивыйРедактор") Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь)
		И СтрНачинаетсяС(ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь, "file")
		И ЭтоАдресВременногоХранилища(Объект.ПутьККрасивомуРедакторуКода) Тогда
		
		Каталог = СтрЗаменить(ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь, "file://", "");
		
		Разд = СтрРазделить(СтрЗаменить(Каталог, "/", "\"), "\", Ложь);
		Разд.Удалить(Разд.ВГраница());
		Каталог = СтрСоединить(Разд, "\");
		
		УдалитьФайлыАсинх(Каталог);
		
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ПолучениеСсылок

// Запрашивает у пользователя навигационную ссылку и возвращает ссылку на объект ИБ
// При возникновении ошибки разбора ссылки формируется предупреждение
//
// Возвращаемое значение:
//  ЛюбаяСсылка - Полученная ссылка
//  Неопределено - При прерывании действия пользователем
//
&НаКлиенте
Асинх Функция УМ_ПолучениеСсылок_ЗапроситьСсылкуИзНавигационнойАсинх()
	ТекстСсылки = Ждать ВвестиСтрокуАсинх(Неопределено, НСтр("ru='Навигационная ссылка'"));
	Если ТекстСсылки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Ссылка = _УМ_ПолучениеСсылок_СсылкаИзНавигационной(ТекстСсылки);
		Возврат Ссылка;
	Исключение
		Ждать ПредупреждениеАсинх(НСтр("ru='Ошибка получения ссылки'"));
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

// Запрашивает выбор пользователем открытого окна программы и возвращает соответствующую окну ссылку на объект ИБ
// При возникновении ошибки разбора ссылки формируется предупреждение
//
// Возвращаемое значение:
//  ЛюбаяСсылка - Полученная ссылка
//  Неопределено - При прерывании действия пользователем
//
&НаКлиенте
Асинх Функция УМ_ПолучениеСсылок_ЗапроситьСсылкуИзОткрытыхОконАсинх()
	Окна = ПолучитьОкна();
	СписокДляВыбора = Новый СписокЗначений;
	
	Для Каждого ОткрытоеОкно Из Окна Цикл
		Если ОткрытоеОкно.НачальнаяСтраница Тогда
			Продолжить;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ОткрытоеОкно.ПолучитьНавигационнуюСсылку()) Тогда
			Продолжить;
		КонецЕсли;
		
		СписокДляВыбора.Добавить(ОткрытоеОкно.ПолучитьНавигационнуюСсылку(), ОткрытоеОкно.Заголовок);
	КонецЦикла;
	
	Если СписокДляВыбора.Количество() = 0 Тогда
		ПоказатьПредупреждение(, НСтр("ru='Нет доступных для выбора окон'"));
		Возврат Неопределено;
	КонецЕсли;
	
	ВыбранныйЭлемент = Ждать СписокДляВыбора.ВыбратьЭлементАсинх(НСтр("ru='Выберите окно'"));
	Если ВыбранныйЭлемент = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Ссылка = _УМ_ПолучениеСсылок_СсылкаИзНавигационной(ВыбранныйЭлемент.Значение);
		Возврат Ссылка;
	Исключение
		Ждать ПредупреждениеАсинх(НСтр("ru='Ошибка получения ссылки'"));
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

// Формирует ссылку на объект ИБ из навигационной ссылки вида "e1cib/data/Справочник.Контрагенты?ref=<GUID>"
// При невозможности сформировать ссылку вызывает исключение
//
// Параметры:
//  НавигационнаяСсылка - Строка - Навигационная ссылка
//
// Возвращаемое значение:
//  Произвольный - Ссылка на объект ИБ
//
&НаСервереБезКонтекста
Функция _УМ_ПолучениеСсылок_СсылкаИзНавигационной(Знач НавигационнаяСсылка)
	ПерваяТочка = СтрНайти(НавигационнаяСсылка, "e1cib/data/");
    ВтораяТочка = СтрНайти(НавигационнаяСсылка, "?ref=");
    
    ПредставлениеТипа = Сред(НавигационнаяСсылка, ПерваяТочка + 11, ВтораяТочка - ПерваяТочка - 11);
    ШаблонЗначения = ЗначениеВСтрокуВнутр(ПредопределенноеЗначение(ПредставлениеТипа + ".ПустаяСсылка"));
	НулевойИдентификатор = "00000000000000000000000000000000";
    ЗначениеСсылки = СтрЗаменить(ШаблонЗначения, НулевойИдентификатор, Сред(НавигационнаяСсылка, ВтораяТочка + 5));
	Возврат ЗначениеИзСтрокиВнутр(ЗначениеСсылки);
КонецФункции

#КонецОбласти

#КонецОбласти

#Область УниверсальныеМеханизмыПереопределяемый

#Область Сохранение

// BSLLS:TransferringParametersBetweenClientAndServer-off
// Параметры процедуры возвратные

// Процедура, определяющая параметры интеграции инструмента с функциями сохранения данных
//
// Параметры:
//  ВерсияФормата - Число - Версия формата XDTO
//  ИмяОбъекта - Строка - Имя объекта XDTO
//  ИмяИнструмента - Строка - Пользовательское представление названия текущего инструмента
//  КлючНастроек - Строка - Ключ настроек хранилища общих настроек для данных автосохранения
//
&НаСервереБезКонтекста
Процедура УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(ВерсияФормата, ИмяОбъекта,
	ИмяИнструмента, КлючНастроек)
	
	//
	
КонецПроцедуры

// BSLLS:TransferringParametersBetweenClientAndServer-on

// Функция формирования пакета XDTO для сохранения в файл
//
// Параметры:
//  Фабрика - ФабрикаXDTO - Фабрика, инициализированная по XSD-схемам Инструментиков
//  Пакет - ОбъектXDTO - Объект для заполнения
//
&НаСервере
Процедура УМ_Сохранение_ПриЗаполненииСохраняемогоОбъектаПереопределяемый(Фабрика, Пакет)
	//
КонецПроцедуры

// Процедура чтения данных из файла
//
// Параметры:
//  Пакет - ОбъектXDTO - Объект для заполнения
//  ВерсияФормата - Число - Версия формата XDTO
//
&НаСервере
Процедура УМ_Сохранение_ПриЧтенииОбъектаПереопределяемый(Пакет, ВерсияФормата)
	//
КонецПроцедуры

// Позволяет выполнить произвольные действия на клиенте после успешной загрузки данных инструмента из файла
//
&НаКлиенте
Процедура УМ_Сохранение_ПослеЧтенияУниверсальногоПакетаПереопределяемый()
	//
КонецПроцедуры

#КонецОбласти

#Область КрасивыйРедактор

// Определяет используемые красивые редакторы кода
//
// Параметры:
//  Редакторы - Массив - Массив структур со следующими свойствами:
//  * ИмяРеквизита - Строка - Имя реквизита формы, хранящего код
//  * ИмяЭлементаТекстовыйДокумент - Строка - Имя элемента формы с текстовым документом редактора кода
//  * ИмяЭлементаHTML - Строка - Имя элемента формы, содержащего связанный HTML-документ
//  * Язык - Строка - Редактируемый язык:
//           "ВстроенныйЯзык" - встроенный язык 1С
//           "ЯзыкЗапросов" - язык запросов 1С
//
&НаСервере
Процедура УМ_КрасивыйРедактор_ПриОпределенииРедакторовПереопределяемый(Редакторы)
	//
КонецПроцедуры

#КонецОбласти

#КонецОбласти

&НаКлиенте
Процедура ПослеВыбораОбъектаИзПримитивнойФормы(ВыбраннаяСсылка, ДополнительныеПараметры) Экспорт
	Если ВыбраннаяСсылка = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Ссылка = ВыбраннаяСсылка;
	ВызватьЧтениеОбъекта();
КонецПроцедуры

&НаСервереБезКонтекста
Функция ЭтоСсылкаНаДокумент(Ссылка)
	Возврат Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Ссылка));
КонецФункции

// Рекомендуется вызывать с клиента вместо прямого вызова ПрочитатьОбъект()
//
&НаКлиенте
Процедура ВызватьЧтениеОбъекта()
	ПрочитатьОбъект();
	КлючУникальности = ?(ЗначениеЗаполнено(Ссылка), Ссылка, Неопределено);
КонецПроцедуры

// Заполняет форму данными объекта
//
&НаСервере
Процедура ПрочитатьОбъект()
	Заголовок = НСтр("ru='Редактор объектов'");
	
	#Область ОчисткаРанееЗагруженныхДанных
	Пока Элементы.СтраницыТЧ.ПодчиненныеЭлементы.Количество() > 0 Цикл
		Элементы.Удалить(Элементы.СтраницыТЧ.ПодчиненныеЭлементы[0]);
	КонецЦикла;
	Пока Элементы.ТекущийНаборДвижений.ПодчиненныеЭлементы.Количество() > 0 Цикл
		Элементы.Удалить(Элементы.ТекущийНаборДвижений.ПодчиненныеЭлементы[0]);
	КонецЦикла;
	
	УдаляемыеРеквизиты = Новый Массив;
	Для Каждого Реквизит Из ПолучитьРеквизиты() Цикл
		Если СтрНачинаетсяС(Реквизит.Имя, "_") Тогда
			УдаляемыеРеквизиты.Добавить(Реквизит.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Реквизит Из ПолучитьРеквизиты("ТекущийНаборДвижений") Цикл
		УдаляемыеРеквизиты.Добавить("ТекущийНаборДвижений." + Реквизит.Имя);
	КонецЦикла;
	ИзменитьРеквизиты(, УдаляемыеРеквизиты);
	
	УдаляемыеКоманды = Новый Массив;
	Для Каждого Команда Из Команды Цикл
		Если СтрНачинаетсяС(Команда.Имя, "_") Тогда
			УдаляемыеКоманды.Добавить(Команда);
		КонецЕсли;
	КонецЦикла;
	Для Каждого Команда Из УдаляемыеКоманды Цикл
		Команды.Удалить(Команда);
	КонецЦикла;
	
	РеквизитыОбъекта.Очистить();
	#КонецОбласти
	
	Модифицированность = Ложь;
	
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Ссылка) И Не ОбъектСуществует(Ссылка) Тогда
		Сообщить("Попытка прочитать несуществующий объект");
		Ссылка = Неопределено;
	КонецЕсли;
	
	Если Ссылка = Неопределено Или Ссылка.Пустая() Тогда
		Элементы.ФормаЗаписать.Доступность = Ложь;
		Элементы.ФормаПеречитать.Доступность = Ложь;
		Элементы.ФормаУдалитьНепосредственно.Доступность = Ложь;
		Элементы.Страницы.Видимость = Ложь;
		Возврат;
	КонецЕсли;
	
	ИзменяемыйОбъект = Ссылка.ПолучитьОбъект();
	Мета = Ссылка.Метаданные();
	
	ЗаписатьВИсториюРедактора(Ссылка);
	
	ЭтоЭлементСправочникаИлиПланаВидовХарактеристик = Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Ссылка)) Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Ссылка));
	
	Для Каждого Реквизит Из ВсеРеквизитыОбъектаМетаданных(Мета, "СтандартныеРеквизиты, Реквизиты") Цикл
		Если ЭтоЭлементСправочникаИлиПланаВидовХарактеристик И ТипЗнч(Реквизит) = Тип("ОбъектМетаданных") Тогда
			Если Реквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы И Не ИзменяемыйОбъект.ЭтоГруппа Тогда
				Продолжить;
			ИначеЕсли Реквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента И ИзменяемыйОбъект.ЭтоГруппа Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		// Стандартный реквизит ДатаОбмена не содержится в объекте узла плана обмена
		// Ошибка проявляется при установленном режиме совместимости конфигурации 8.3.22 и выше
		// К тому же, данный реквизит не предназначен для записи (по крайней мере, так написано в синтакс-помощнике)
		Если Объект.РежимСовместимостиКонфигурации >= 3.22 И Метаданные.ПланыОбмена.Содержит(Мета) И Реквизит.Имя = "ДатаОбмена" Тогда
			Продолжить;
		КонецЕсли;
		
		Стр = РеквизитыОбъекта.Добавить();
		Стр.Имя = Реквизит.Имя;
		Стр.Синоним = Реквизит.Представление();
		Стр.РеквизитТребуетЗаполнения = (Реквизит.ПроверкаЗаполнения = ПроверкаЗаполнения.ВыдаватьОшибку);
		Стр.Значение = ИзменяемыйОбъект[Стр.Имя];
		Стр.ЗначениеЗаполнено = ?(ТипЗнч(Стр.Значение) = Тип("Булево"), Стр.Значение = Истина, ЗначениеЗаполнено(Стр.Значение));
		Стр.ИмяЗначения = ИмяЗначения(Стр.Значение);
		Стр.ПервоначальноеЗначение = ИзменяемыйОбъект[Стр.Имя];
		
		Стр.ТипЗначения = Реквизит.Тип;
		Стр.ИмяТипаМетаданных = ИмяТипаКакВКонфигураторе(Реквизит.Тип);
		Стр.ИмяТипаЗначения = ИмяТипаКакВКонфигураторе(ТипЗнч(Стр.Значение));
	КонецЦикла;
	
	ЗаполнитьТабличныеЧасти(ИзменяемыйОбъект);
	ЭтоДокумент = Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Ссылка));
	Элементы.ПрочитатьДвижения.Видимость = ЭтоДокумент;
	Элементы.ФормаПроанализироватьИзмененияВДвижениях.Доступность = ЭтоДокумент;
	Элементы.ФормаПровестиДокумент.Доступность = ЭтоДокумент;
	Элементы.ФормаОтменитьПроведениеДокумента.Доступность = ЭтоДокумент;
	Элементы.ГруппаВыборРегистраДвижений.Видимость = Ложь;
	Если ЭтоДокумент Тогда
		КоличествоНаборовДвижений = ИзменяемыйОбъект.Движения.Количество();
		Элементы.СтраницаДвижения.Заголовок = СтрШаблон("Движения (%1)", Формат(КоличествоНаборовДвижений, "ЧН=0"));
		Элементы.СтраницаДвижения.Доступность = (КоличествоНаборовДвижений > 0);
	КонецЕсли;
	
	Модифицированность = Ложь;
	Элементы.ФормаЗаписать.Доступность = Истина;
	Элементы.ФормаПеречитать.Доступность = Истина;
	Элементы.ФормаУдалитьНепосредственно.Доступность = Истина;
	Элементы.Страницы.Видимость = Истина;
	
	УникальныйИдентификаторОбъекта = Ссылка.УникальныйИдентификатор();
	НавигационнаяСсылкаОбъекта = ПолучитьНавигационнуюСсылку(Ссылка);
	ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя();
	ДатаСозданияОбъекта = ДатаСозданияСсылки(Ссылка.УникальныйИдентификатор());
	
	Заголовок = СтрШаблон(НСтр("ru='%1 - Редактор объектов'"), Строка(Ссылка));
КонецПроцедуры

// Заполнение табличных частей на форме табличными частями объекта
//
// Параметры:
//  ИзменяемыйОбъект - Произвольный - Оъект ИБ ссылочного типа
&НаСервере
Процедура ЗаполнитьТабличныеЧасти(ИзменяемыйОбъект)
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	СписокВыбораТабличныхЧастей.Очистить();
	ТекущаяТЧ = Неопределено;
	Элементы.СтраницаТЧ.Доступность = (Ссылка.Метаданные().ТабличныеЧасти.Количество() > 0);
	Элементы.СтраницаТЧ.Заголовок = СтрШаблон("Табличные части (%1)", Ссылка.Метаданные().ТабличныеЧасти.Количество());
	
	// ++ Создание реквизитов
	Для Каждого ТЧ Из Ссылка.Метаданные().ТабличныеЧасти Цикл
		ДобавляемыеРеквизиты = Новый Массив;
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(СтрШаблон("_ТЧ_%1", ТЧ.Имя), Новый ОписаниеТипов("ТаблицаЗначений"),, ТЧ.Синоним, Истина));
		
		Для Каждого РеквизитТЧ Из ВсеРеквизитыОбъектаМетаданных(ТЧ, "СтандартныеРеквизиты, Реквизиты") Цикл
			Если РеквизитТЧ.Тип.СодержитТип(Тип("ХранилищеЗначения")) Тогда
				Продолжить;
			КонецЕсли;
			ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(РеквизитТЧ.Имя, РеквизитТЧ.Тип, СтрШаблон("_ТЧ_%1", ТЧ.Имя), РеквизитТЧ.Синоним, Истина));
		КонецЦикла;
		
		ИзменитьРеквизиты(ДобавляемыеРеквизиты);
	КонецЦикла;
	// -- Создание реквизитов
	
	РеквизитыТЧ = Новый Структура;
	// ++ Создание таблиц на форме
	Для Каждого РеквизитТЧ Из ПолучитьРеквизиты() Цикл
		Если Не СтрНачинаетсяС(РеквизитТЧ.Имя, "_ТЧ_") Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТЧ = СтрЗаменить(РеквизитТЧ.Имя, "_ТЧ_", "");
		РеквизитыТЧ.Вставить(ИмяТЧ, ЭтаФорма[РеквизитТЧ.Имя]);
		
		Страница = Элементы.Добавить("Страница" + ИмяТЧ, Тип("ГруппаФормы"), Элементы.СтраницыТЧ);
		Страница.Вид = ВидГруппыФормы.Страница;
		Страница.Заголовок = РеквизитТЧ.Заголовок;
		
		НадписьИмяВКонфигураторе = Элементы.Добавить("ТЧ_ИмяВКонфигураторе_" + ИмяТЧ, Тип("ДекорацияФормы"), Страница);
		НадписьИмяВКонфигураторе.Вид = ВидДекорацииФормы.Надпись;
		НадписьИмяВКонфигураторе.АвтоМаксимальнаяШирина = Ложь;
		НадписьИмяВКонфигураторе.Заголовок = "Имя в конфигураторе: " + ИмяТЧ;
		
		Таблица = Элементы.Добавить("ТЧ_" + ИмяТЧ, Тип("ТаблицаФормы"), Страница);
		Таблица.ПутьКДанным = РеквизитТЧ.Имя;
		Таблица.УстановитьДействие("ПриИзменении", "ТабличнаяЧастьПриИзменении");
		Таблица.УстановитьДействие("Выбор", "ТабличнаяЧастьВыбор");
		
		КнопкаКонтекстногоМеню = Элементы.Добавить("КнопкаТЧ_" + ИмяТЧ, Тип("КнопкаФормы"), Таблица.КонтекстноеМеню);
		КнопкаКонтекстногоМеню.ИмяКоманды = "ОткрытьРеквизитТЧВРедакторе";
		
		Для Каждого ДочернийРеквизит Из ПолучитьРеквизиты(РеквизитТЧ.Имя) Цикл
			Поле = Элементы.Добавить("ТЧ_" + ИмяТЧ + "_" + ДочернийРеквизит.Имя, Тип("ПолеФормы"), Таблица);
			Поле.Вид = ВидПоляФормы.ПолеВвода;
			Поле.ПутьКДанным = СтрШаблон("%1.%2", РеквизитТЧ.Имя, ДочернийРеквизит.Имя);
			Поле.Заголовок = ДочернийРеквизит.Заголовок;
			Поле.Подсказка = ДочернийРеквизит.Имя;
		КонецЦикла;
		
		СписокВыбораТабличныхЧастей.Добавить(ИмяТЧ, РеквизитТЧ.Заголовок);
	КонецЦикла;
	// -- Создание таблиц на форме
	
	// ++ Заполнение таблиц данными
	Для Каждого ТЧ Из Ссылка.Метаданные().ТабличныеЧасти Цикл
		Для Каждого СТЧ Из ИзменяемыйОбъект[ТЧ.Имя] Цикл
			СтрТаблицы = РеквизитыТЧ[ТЧ.Имя].Добавить();
			ЗаполнитьЗначенияСвойств(СтрТаблицы, СТЧ);
		КонецЦикла;
	КонецЦикла;
	// -- Заполнение таблиц данными
	
	СписокВыбораТабличныхЧастей.СортироватьПоПредставлению();
	ОбновитьОтображаемыйСписокВыбораТабличныхЧастей(ЭтотОбъект);
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура ОбновитьОтображаемыйСписокВыбораТабличныхЧастей(Форма)
	СписокПриемник = Форма.Элементы.ТекущаяТЧ.СписокВыбора;
	СписокПриемник.Очистить();
	
	Для Каждого ЭлементИсточник Из Форма.СписокВыбораТабличныхЧастей Цикл
		КоличествоСтрокТЧ = Форма[СтрШаблон("_ТЧ_%1", ЭлементИсточник.Значение)].Количество();
		
		Если КоличествоСтрокТЧ = 0 И Не Форма.ПоказыватьПустыеТабличныеЧасти Тогда
			Продолжить;
		КонецЕсли;
		
		ПредставлениеКоличестваСтрок = Формат(КоличествоСтрокТЧ, "ЧН=0");
		СписокПриемник.Добавить(ЭлементИсточник.Значение, СтрШаблон("%1 (%2)", ЭлементИсточник.Представление, ПредставлениеКоличестваСтрок));
	КонецЦикла;
	
	Если СписокПриемник.Количество() > 0 Тогда
		Форма.Элементы.СтраницыТЧ.Видимость = Истина;
		
		Если СписокПриемник.НайтиПоЗначению(Форма.ТекущаяТЧ) = Неопределено Тогда
			Форма.ТекущаяТЧ = СписокПриемник[0].Значение;
			Форма.Элементы.СтраницыТЧ.ТекущаяСтраница = Форма.Элементы["Страница" + Форма.ТекущаяТЧ];
		КонецЕсли;
	Иначе
		ТекущаяТЧ = Неопределено;
		Форма.Элементы.СтраницыТЧ.Видимость = Ложь;
	КонецЕсли;
КонецПроцедуры

// Получает и заполняет таблицы движений открытого объекта
//
&НаСервере
Процедура ЗаполнитьДвижения()
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	ДвиженияОбъекта.Очистить();
	
	// Создаем пустой объект для определения его движений
	ИсточникДвижений = Новый(СтрЗаменить(Ссылка.Метаданные().ПолноеИмя(), ".", "Объект."));
		
	Элементы.ВыбранныйНаборДвижений.СписокВыбора.Очистить();
	ВыбранныйНаборДвижений = Неопределено;
	
	ЧастиЗапроса = Новый Массив;
	НаборыЗаписей = Новый Массив;
	Для Каждого НаборЗаписей Из ИсточникДвижений.Движения Цикл
		ЧастьЗапроса = "ВЫБРАТЬ * ИЗ &Таблица КАК Таблица ГДЕ Таблица.Регистратор = &Ссылка;";
		МетаданныеНабораЗаписей = НаборЗаписей.Метаданные();
		ПолноеИмяМетаданныхНабораЗаписей = МетаданныеНабораЗаписей.ПолноеИмя();
		ЧастьЗапроса = СтрЗаменить(ЧастьЗапроса, "&Таблица", ПолноеИмяМетаданныхНабораЗаписей);
		ЧастиЗапроса.Добавить(ЧастьЗапроса);
		НаборыЗаписей.Добавить(НаборЗаписей);
	КонецЦикла;
	
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(ЧастиЗапроса, Символы.ПС);
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Результаты = Запрос.ВыполнитьПакет();
	
	Для Сч = 0 По Результаты.ВГраница() Цикл
		ВыгрузкаИзЗапроса = Результаты[Сч].Выгрузить();
		
		Выгрузка = Новый ТаблицаЗначений;
		Для Каждого КолонкаИсточник Из ВыгрузкаИзЗапроса.Колонки Цикл
			ТипЗначения = Новый ОписаниеТипов(КолонкаИсточник.ТипЗначения,, "Null");
			Выгрузка.Колонки.Добавить(КолонкаИсточник.Имя, ТипЗначения, КолонкаИсточник.Заголовок);
		КонецЦикла;
		
		Для Каждого СтрИсточник Из ВыгрузкаИзЗапроса Цикл
			СтрПриемник = Выгрузка.Добавить();
			ЗаполнитьЗначенияСвойств(СтрПриемник, СтрИсточник);
		КонецЦикла;
		
		ИсходныйНаборЗаписей = НаборыЗаписей[Сч];
		
		ПолноеИмяМетаданныхНабораЗаписей = ИсходныйНаборЗаписей.Метаданные().ПолноеИмя();
		
		Представление = ИсходныйНаборЗаписей.Метаданные().Синоним;
		Если Выгрузка.Количество() > 0 Тогда
			Представление = Представление + СтрШаблон(" (%1)", Формат(Выгрузка.Количество(), "ЧГ="));
		КонецЕсли;
		
		СтрДвижения = ДвиженияОбъекта.Добавить();
		СтрДвижения.ИмяНабора = ПолноеИмяМетаданныхНабораЗаписей;
		СтрДвижения.Представление = Представление;
		СтрДвижения.ИмяКартинки = СтрРазделить(ПолноеИмяМетаданныхНабораЗаписей, ".")[0];
		СтрДвижения.Таблица = Новый ХранилищеЗначения(Выгрузка, Новый СжатиеДанных(9));
		СтрДвижения.Пустой = (Выгрузка.Количество() = 0);
	КонецЦикла;
	
	Элементы.ВыбранныйНаборДвижений.СписокВыбора.СортироватьПоПредставлению();
	Элементы.ГруппаВыборРегистраДвижений.Видимость = Истина;
	
	ЗаполнитьСписокВыбораНабораДвижений(Истина);
КонецПроцедуры

// Заполняет таблицу текущего набора движений
//
&НаСервере
Процедура ИнициализироватьТаблицуТекущегоНабораДвижений()
	Пока Элементы.ТекущийНаборДвижений.ПодчиненныеЭлементы.Количество() > 0 Цикл
		Элементы.Удалить(Элементы.ТекущийНаборДвижений.ПодчиненныеЭлементы[0]);
	КонецЦикла;
	
	УдаляемыеРеквизиты = Новый Массив;
	Для Каждого Реквизит Из ПолучитьРеквизиты("ТекущийНаборДвижений") Цикл
		УдаляемыеРеквизиты.Добавить("ТекущийНаборДвижений." + Реквизит.Имя);
	КонецЦикла;
	ИзменитьРеквизиты(, УдаляемыеРеквизиты);
	
	Если Не ЗначениеЗаполнено(ВыбранныйНаборДвижений) Тогда
		Возврат;
	КонецЕсли;
	СтрДвижения = ДвиженияОбъекта.НайтиСтроки(Новый Структура("ИмяНабора", ВыбранныйНаборДвижений))[0];
	Таблица = СтрДвижения.Таблица.Получить();
	
	ДобавляемыеРеквизиты = Новый Массив;
	Для Каждого Колонка Из Таблица.Колонки Цикл
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, "ТекущийНаборДвижений", Колонка.Заголовок));
	КонецЦикла;
	ИзменитьРеквизиты(ДобавляемыеРеквизиты);
	
	Для Каждого Колонка Из Таблица.Колонки Цикл
		ПолеТаблицы = Элементы.Добавить("ТекущийНаборДвижений_" + Колонка.Имя, Тип("ПолеФормы"), Элементы.ТекущийНаборДвижений);
		ПолеТаблицы.Вид = ?(Колонка.ТипЗначения = Новый ОписаниеТипов("Булево"), ВидПоляФормы.ПолеФлажка, ВидПоляФормы.ПолеВвода);
		ПолеТаблицы.ПутьКДанным = "ТекущийНаборДвижений." + Колонка.Имя;
	КонецЦикла;
	
	ТекущийНаборДвижений.Загрузить(Таблица);
КонецПроцедуры

// Записывает изменённые реквизиты и перезаписывает все ТЧ открытого объекта
//
// Параметры:
//  РежимЗаписиСтрокой - Строка - Допустимы значения: "Запись", "Проведение", "ОтменаПроведения". Применяется и учитывается только при записи документов
//  ПеречитатьПослеЗаписи - Булево - Выполнять ли перечитывание объекта при успешной записи
//  СохраняемыйОбъект - Неопределено, Произвольный - Ранее полученный объект.
//                      Ссылка в объекте должна совпадать с выбранной на форме
&НаСервере
Процедура ЗаписатьНаСервере(Знач РежимЗаписиСтрокой = "Запись", Знач ПеречитатьПослеЗаписи = Истина, Знач СохраняемыйОбъект = Неопределено)
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	Если Не ОбъектСуществует(Ссылка) Тогда
		Сообщить("Попытка записать несуществующий объект");
		Возврат;
	КонецЕсли;
	
	Если СохраняемыйОбъект = Неопределено Тогда
		СохраняемыйОбъект = Ссылка.ПолучитьОбъект();
	КонецЕсли;
	Если СохраняемыйОбъект.Ссылка <> Ссылка Тогда
		НавСсылкаВФорме = ПолучитьНавигационнуюСсылку(Ссылка);
		НавСсылкаПереданного = ПолучитьНавигационнуюСсылку(СохраняемыйОбъект.Ссылка);
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Несоответствие ссылки в реквизите формы и ссылки, переданной в параметр СохраняемыйОбъект в ЗаписатьНаСервере():
                                          |Ссылка в форме: %1
                                          |Ссылка переданного объекта: %2'"), НавСсылкаВФорме, НавСсылкаПереданного);
	КонецЕсли;
	
	Если ОбменДаннымиЗагрузка Тогда
		СохраняемыйОбъект.ОбменДанными.Загрузка = Истина;
	КонецЕсли;
	
	Для Каждого Строка Из РеквизитыОбъекта Цикл
		Если Не Строка.Изменено Тогда
			Продолжить;
		КонецЕсли;
		
		СохраняемыйОбъект[Строка.Имя] = Строка.Значение;
	КонецЦикла;
	
	Для Каждого Рекв Из ПолучитьРеквизиты() Цикл
		Если Не СтрНачинаетсяС(Рекв.Имя, "_ТЧ_") Тогда
			Продолжить;
		КонецЕсли;
		ИмяТЧ = СтрЗаменить(Рекв.Имя, "_ТЧ_", "");
		
		ТаблЧастьИзФормы = РеквизитФормыВЗначение(Рекв.Имя, Тип("ТаблицаЗначений"));
		СохраняемыйОбъект[ИмяТЧ].Очистить();
		Для Каждого ВходящаяСтр Из ТаблЧастьИзФормы Цикл
			ЗаполнитьЗначенияСвойств(СохраняемыйОбъект[ИмяТЧ].Добавить(), ВходящаяСтр);
		КонецЦикла;
	КонецЦикла;
	
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Ссылка)) Тогда
		Если РежимЗаписиСтрокой = "Запись" Тогда
			РежимЗаписи = РежимЗаписиДокумента.Запись;
		ИначеЕсли РежимЗаписиСтрокой = "Проведение" Тогда
			РежимЗаписи = РежимЗаписиДокумента.Проведение;
		ИначеЕсли РежимЗаписиСтрокой = "ОтменаПроведения" Тогда
			РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения;
		Иначе
			ВызватьИсключение "Некорректный режим записи " + РежимЗаписиСтрокой;
		КонецЕсли;
		
		СохраняемыйОбъект.Записать(РежимЗаписи);
	Иначе
		СохраняемыйОбъект.Записать();
	КонецЕсли;
	
	Если ПеречитатьПослеЗаписи Тогда
		ПрочитатьОбъект();
	КонецЕсли;
КонецПроцедуры

// Запрашивает сохранение данных перед действиями, выполнение которых приведёт к потере изменений
//
// Возвращаемое значение:
//  Булево - Продолжить выполнение действия
&НаКлиенте
Асинх Функция ЗапроситьСохранениеАсинх()
	Если Не Модифицированность Тогда
		Возврат Истина;
	КонецЕсли;
	
	Ответ = Ждать ВопросАсинх("Данные объекта не сохранены. Сохранить?", РежимДиалогаВопрос.ДаНетОтмена);
	Если Ответ = КодВозвратаДиалога.Да Тогда
		ЗаписатьНаСервере(, Ложь);
		Модифицированность = Ложь;
		Возврат Истина;
	ИначеЕсли Ответ = КодВозвратаДиалога.Нет Тогда
		Модифицированность = Ложь;
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

// Запрашивает сохранение данных перед закрытием формы
// Если пользователь нажал на кнопку, отличную от "Отмена", прозойдёт запись (при необходимости) и закрытие формы
//
&НаКлиенте
Асинх Процедура ПередЗакрытиемАсинх()
	Если Ждать ЗапроситьСохранениеАсинх() Тогда
		Закрыть();
	КонецЕсли;
КонецПроцедуры

// Выполняет непосредственное удаление объекта
//
// Параметры:
//  Ссылка - Произвольный - Ссылка на удаляемый объект
//  ПривилегированныйРежим - Булево - Нужно ли устанавливать привилегированный режим перед получением и удалением объекта
//  ОбменДаннымиЗагрузка - Булево - Нужно ли устанавливать флаг ОбменДанными.Загрузка перед удалением объекта
&НаСервереБезКонтекста
Процедура УдалитьНепосредственноНаСервере(Ссылка, ПривилегированныйРежим, ОбменДаннымиЗагрузка)
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	Объект = Ссылка.ПолучитьОбъект();
	Если ОбменДаннымиЗагрузка Тогда
		Объект.ОбменДанными.Загрузка = Истина;
	КонецЕсли;
	
	Объект.Удалить();
КонецПроцедуры

// Формирует имя переданного типа в таком виде, в котором оно обычно пишется в конфигураторе
// Например, "Число", "СправочникСсылка.Контрагенты", "ДокументСсылка.РеализацияТоваровУслуг"
//
// Параметры:
//  ТипИлиОписаниеТипов - Тип, ОписаниеТипов -
//
// Возвращаемое значение:
//  Строка - Представление для вывода пользователю
&НаСервереБезКонтекста
Функция ИмяТипаКакВКонфигураторе(ТипИлиОписаниеТипов)
	Если ТипЗнч(ТипИлиОписаниеТипов) = Тип("ОписаниеТипов") Тогда
		Если ТипИлиОписаниеТипов.Типы().Количество() = 1 Тогда
			Возврат ИмяТипаКакВКонфигураторе(ТипИлиОписаниеТипов.Типы()[0]);
		Иначе
			ВсеТипы = Новый Массив;
			Для Каждого Тип Из ТипИлиОписаниеТипов.Типы() Цикл
				ВсеТипы.Добавить(ИмяТипаКакВКонфигураторе(Тип));
			КонецЦикла;
			Возврат СтрСоединить(ВсеТипы, "; ");
		КонецЕсли;
	Иначе
		Если ТипИлиОписаниеТипов = Тип("Неопределено") Тогда
			Возврат "Неопределено";
		КонецЕсли;
		
		XMLТип = XMLТип(ТипИлиОписаниеТипов);
		Если XMLТип = Неопределено Тогда
			Возврат СтрШаблон("<не удалось найти XML-описание типа ""%1"">", Строка(ТипИлиОписаниеТипов));
		КонецЕсли;
		
		Результат = СтрЗаменить(XMLТип.ИмяТипа, "decimal", "Число");
		Результат = СтрЗаменить(Результат, "boolean", "Булево");
		Результат = СтрЗаменить(Результат, "string", "Строка");
		Результат = СтрЗаменить(Результат, "dateTime", "Дата");
		Результат = СтрЗаменить(Результат, "UUID", "УникальныйИдентификатор");
		Результат = СтрЗаменить(Результат, "ValueStorage", "ХранилищеЗначения");
		
		Результат = СтрЗаменить(Результат, "CatalogRef", "СправочникСсылка");
		Результат = СтрЗаменить(Результат, "DocumentRef", "ДокументСсылка");
		Результат = СтрЗаменить(Результат, "EnumRef", "ПеречислениеСсылка");
		Результат = СтрЗаменить(Результат, "ChartOfAccountsRef", "ПланСчетовСсылка");
		Результат = СтрЗаменить(Результат, "ChartOfCharacteristicTypesRef", "ПланВидовХарактеристикСсылка");
		Результат = СтрЗаменить(Результат, "ChartOfCalculationTypesRef", "ПланВидовРасчетаСсылка");
		Результат = СтрЗаменить(Результат, "ExchangePlanRef", "ПланОбменаСсылка");
		Результат = СтрЗаменить(Результат, "BusinessProcessRef", "БизнесПроцессСсылка");
		Результат = СтрЗаменить(Результат, "BusinessProcessRoutePointRef", "ТочкаМаршрутаБизнесПроцессаСсылка");
		Результат = СтрЗаменить(Результат, "TaskRef", "ЗадачаСсылка");
		Возврат Результат;
	КонецЕсли;
КонецФункции

// Показать пользователю выбор типа значения строки таблицы РеквизитыОбъекта
// Если пользователь не откажется от выбора, значение реквизита будет изменено на пустое выбранного типа
// Если реквизит имеет несоставной тип, будет просто выдано предупреждение
//
// Параметры:
//  СтрокаТаблицыРеквизитов - ДанныеФормыСтруктура - Строка таблицы Реквизиты
&НаКлиенте
Асинх Процедура ВыбратьТипЗначенияАсинх(СтрокаТаблицыРеквизитов)
	Если СтрокаТаблицыРеквизитов.ТипЗначения.Типы().Количество() = 1 Тогда
		ПоказатьПредупреждение(, "У этого реквизита не составной тип");
		Возврат;
	КонецЕсли;
	
	Список = Новый СписокЗначений;
	Список.ЗагрузитьЗначения(СтрокаТаблицыРеквизитов.ТипЗначения.Типы());
	
	Ответ = Ждать Список.ВыбратьЭлементАсинх("Выберите тип", Список.НайтиПоЗначению(ТипЗнч(СтрокаТаблицыРеквизитов.Значение)));
	Если Ответ = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Ответ.Значение);
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	СтрокаТаблицыРеквизитов.Значение = ОписаниеТипов.ПривестиЗначение(Неопределено);
	СтрокаТаблицыРеквизитов.ЗначениеЗаполнено = ЗначениеЗаполнено(СтрокаТаблицыРеквизитов.Значение);
	
	СтрокаТаблицыРеквизитов.ИмяТипаЗначения = ИмяТипаКакВКонфигураторе(Ответ.Значение);
	
	Модифицированность = Истина;
	СтрокаТаблицыРеквизитов.Изменено = (СтрокаТаблицыРеквизитов.Значение <> СтрокаТаблицыРеквизитов.ПервоначальноеЗначение);
КонецПроцедуры

// Получить список всех реквизитов объекта метаданных, включая стандартные
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных -
//  ИменаКоллекцийРеквизитов - Строка - Перечисленные через запятую имена свойств, являющихся коллекциями реквизитов. Например, "СтандартныеРеквизиты, Реквизиты"
//
// Возвращаемое значение:
//  Массив - Массив значений типа ОбъектМетаданных (реквизит)
&НаСервереБезКонтекста
Функция ВсеРеквизитыОбъектаМетаданных(ОбъектМетаданных, ИменаКоллекцийРеквизитов)
	Результат = Новый Массив;
	
	Для Каждого ИмяКоллекции Из СтрРазделить(ИменаКоллекцийРеквизитов, ",") Цикл
		Для Каждого Реквизит Из ОбъектМетаданных[СокрЛП(ИмяКоллекции)] Цикл
			Если ИмяКоллекции = "СтандартныеРеквизиты" И (Реквизит.Имя = "Ссылка" Или Реквизит.Имя = "Регистратор") Тогда
				Продолжить;
			КонецЕсли;
			Результат.Добавить(Реквизит);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Формирует ОписаниеТипов, содержащее все типы всех ссылочных объектов, которые можно создавать в режиме Предприятия
// Необходимо для включения типов из расширений в ограничение типа
//
// Возвращаемое значение:
//  ОписаниеТипов
&НаСервереБезКонтекста
Функция ОграничениеТипаВсеСсылки()
	ОграничениеТипа = Новый ОписаниеТипов;
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Справочники);
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Документы);
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, ПланыВидовХарактеристик);
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, ПланыСчетов);
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, ПланыВидовРасчета);
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, БизнесПроцессы);
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Задачи);
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, ПланыОбмена);
	Возврат ОграничениеТипа;
КонецФункции

// Добавляет в ИсходноеОписаниеТипов все ссылочные типы из коллекции Коллекция
//
// Параметры:
//  ИсходноеОписаниеТипов - ОписаниеТипов - Расширяемое описание типов
//  Коллекция - Произвольный - Коллекция менеджеров объектов метаданных, содержащая функцию ТипВсеСсылки()
//
// Возвращаемое значение:
//  ОписаниеТипов -
&НаСервереБезКонтекста
Функция ОписаниеТиповКоллекцииОбъектовМетаданных(ИсходноеОписаниеТипов, Коллекция)
	ДобавляемыеТипы = Коллекция.ТипВсеСсылки().Типы();
	Результат = Новый ОписаниеТипов(ИсходноеОписаниеТипов, ДобавляемыеТипы);
	Возврат Результат;
КонецФункции

// Записывает набор движений по указанному регистру без перезаписи документа
//
// Параметры:
//  ИмяРегистра - Строка - Имя набора движений объекта
&НаСервере
Процедура ЗаписатьДвиженияНаСервере()
	ИзменяемыйОбъект = Ссылка.ПолучитьОбъект();
	НаборЗаписей = ИзменяемыйОбъект.Движения[СтрРазделить(ВыбранныйНаборДвижений, ".")[1]];
	Источник = ТекущийНаборДвижений.Выгрузить();
	
	НаборЗаписей.Загрузить(Источник);
	НаборЗаписей.Записать();
КонецПроцедуры

// Выполняет анализ изменения движений объекта при его перезаписи с указанными пользователем изменениями
//
// Возвращаемое значение:
//  ТабличныйДокумент - При наличии различий в движениях
//  Неопределено - Если движения до и после записи идентичны
&НаСервере
Функция ПроанализироватьИзмененияВДвиженияхНаСервере()
	НачатьТранзакцию();
	Попытка
		ДвиженияДоЗаписи = ВсеДвиженияДокумента(Ссылка);
		ЗаписатьНаСервере("Проведение", Ложь);
		ДвиженияПослеЗаписи = ВсеДвиженияДокумента(Ссылка);
		ОтменитьТранзакцию();
		
		ТаблДокРезультат = Неопределено;
		
		Для Каждого КЗ Из ДвиженияДоЗаписи Цикл
			ИмяРегистра = КЗ.Ключ;
			ДоЗаписи = КЗ.Значение;
			ПослеЗаписи = ДвиженияПослеЗаписи[ИмяРегистра];
			
			Расхождения = РасхожденияМеждуДвумяТаблицами(ДоЗаписи, ПослеЗаписи);
			Если Расхождения.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ПостроительОтчета = Новый ПостроительОтчета;
			ПостроительОтчета.ИсточникДанных = Новый ОписаниеИсточникаДанных(Расхождения);
			ПостроительОтчета.ВыводитьЗаголовокОтчета = Истина;
			ПостроительОтчета.ТекстЗаголовка = ИмяРегистра;
			
			Если ТаблДокРезультат = Неопределено Тогда
				ТаблДокРезультат = Новый ТабличныйДокумент;
			КонецЕсли;
			ПостроительОтчета.Вывести(ТаблДокРезультат);
		КонецЦикла;
	Исключение
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат ТаблДокРезультат;
КонецФункции

// Получает все движения документа, выгруженные в таблицы значений
//
// Параметры:
//  Ссылка - ДокументСсылка - Ссылка на документ
//
// Возвращаемое значение:
//  Соответствие - Ключ: Строка, имя набора движений; Значение: ТаблицаЗначений, выгруженный набор записей регистра
&НаСервереБезКонтекста
Функция ВсеДвиженияДокумента(Ссылка)
	Результат = Новый Соответствие;
	Объект = Ссылка.ПолучитьОбъект();
	Для Каждого НаборДвижений Из Объект.Движения Цикл
		НаборДвижений.Прочитать();
		Результат[НаборДвижений.Метаданные().Имя] = НаборДвижений.Выгрузить();
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Сравнивает две таблицы значений и формирует сводную таблицу, включающую только отличающиеся строки
// Таблицы должны иметь одинаковую структуру колонок
//
// Параметры:
//  Таблица1 - ТаблицаЗначений -
//  Таблица2 - ТаблицаЗначений -
//
// Возвращаемое значение:
//  ТаблицаЗначений -
&НаСервереБезКонтекста
Функция РасхожденияМеждуДвумяТаблицами(Таблица1, Таблица2)
	ВсеКолонки = Новый Массив;
	Для Каждого Колонка Из Таблица1.Колонки Цикл
		ВсеКолонки.Добавить(Колонка.Имя);
	КонецЦикла;
	ВсеКолонки = СтрСоединить(ВсеКолонки, ", ");
	
	Таблица1.Колонки.Добавить("_НомерТаблицы", Новый ОписаниеТипов("Число"));
	Таблица1.ЗаполнитьЗначения(0, "_НомерТаблицы");
	
	Таблица2.Колонки.Добавить("_НомерТаблицы", Новый ОписаниеТипов("Число"));
	Таблица2.ЗаполнитьЗначения(1, "_НомерТаблицы");
	
	СводнаяТаблица = Таблица1.Скопировать();
	Для Каждого Стр Из Таблица2 Цикл
		ЗаполнитьЗначенияСвойств(СводнаяТаблица.Добавить(), Стр);
	КонецЦикла;
	
	СводнаяТаблица.Колонки.Добавить("_Счет", Новый ОписаниеТипов("Число"));
	СводнаяТаблица.ЗаполнитьЗначения(1, "_Счет");
	
	СводнаяТаблица.Свернуть(ВсеКолонки, "_НомерТаблицы, _Счет");
	
	СводнаяТаблица.Колонки.Добавить("_Источник", Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(СтрДлина("После записи"))));
	Для Каждого Стр Из СводнаяТаблица Цикл
		Стр._Источник = ?(Стр._НомерТаблицы = 0, "До записи", "После записи");
	КонецЦикла;
	
	Результат = СводнаяТаблица.Скопировать(Новый Структура("_Счет", 1), "_Источник, " + ВсеКолонки);
	Возврат Результат;
КонецФункции

&НаСервереБезКонтекста
Функция ИмяЗначения(Значение)
	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат XMLСтрока(Значение);
	КонецЕсли;
КонецФункции

// Универсальная процедура сортировки таблицы значений
//
// Параметры:
//  ИмяТаблицыФормы - Строка - Имя элемента формы, ссылающегося на таблицу
//  Направление - Строка - "Возр" или "Убыв"
&НаСервере
Процедура СортироватьТаблицуЗначений(ИмяТаблицыФормы, Направление)
	ТаблицаФормы = Элементы[ИмяТаблицыФормы];
	ПрефиксПутиКДанным = ТаблицаФормы.ПутьКДанным + ".";
	
	ТекущаяКолонка = ТаблицаФормы.ТекущийЭлемент;
	ИмяКолонки = СтрЗаменить(ТекущаяКолонка.ПутьКДанным, ПрефиксПутиКДанным, "");
	
	ЭтотОбъект[ТаблицаФормы.ПутьКДанным].Сортировать(ИмяКолонки + " " + Направление);
КонецПроцедуры

// Применяет отборы таблицы значений на основании реквизитов формы ОтборРеквизитовТолькоЗаполненные и ОтборРеквизитовТолькоТребущиеЗаполнения
//
&НаКлиенте
Процедура УстановитьОтборРеквизитов()
	ОтборСтрок = Новый Структура;
	
	Если ОтборРеквизитовТолькоЗаполненные Тогда
		ОтборСтрок.Вставить("ЗначениеЗаполнено", Истина);
	КонецЕсли;
	Если ОтборРеквизитовТолькоТребущиеЗаполнения Тогда
		ОтборСтрок.Вставить("РеквизитТребуетЗаполнения", Истина);
	КонецЕсли;
	
	Элементы.РеквизитыОбъекта.ОтборСтрок = Новый ФиксированнаяСтруктура(ОтборСтрок);
	
	Элементы.РеквизитыОбъектаОтобратьРеквизитыТолькоЗаполненные.Пометка = ОтборРеквизитовТолькоЗаполненные;
	Элементы.РеквизитыОбъектаОтобратьРеквизитыТолькоТребующиеЗаполнения.Пометка = ОтборРеквизитовТолькоТребущиеЗаполнения;
КонецПроцедуры

// Заполняет список выбора элемента формы ВыбранныйНаборДвижений
//
// Параметры:
//  ЭтоПеречитываниеОбъекта - Булево - Следует установить в Истина, если происходит перечитывание одного и того же объекта
//                                     Влияет на автоматический выбор первого регистра из списка после заполнения списка выбора
&НаСервере
Процедура ЗаполнитьСписокВыбораНабораДвижений(ЭтоПеречитываниеОбъекта = Ложь)
	СписокВыбора = Элементы.ВыбранныйНаборДвижений.СписокВыбора;
	СписокВыбора.Очистить();
	
	Для Каждого СтрДвижения Из ДвиженияОбъекта Цикл
		ИмяТипа = СтрРазделить(СтрДвижения.ИмяНабора, ".")[0];
		Если ИмяТипа = "РегистрСведений" И Не ПоказыватьРегистрыСведений Тогда
			Продолжить;
		ИначеЕсли ИмяТипа = "РегистрНакопления" И Не ПоказыватьРегистрыНакопления Тогда
			Продолжить;
		ИначеЕсли ИмяТипа = "РегистрБухгалтерии" И Не ПоказыватьРегистрыБухгалтерии Тогда
			Продолжить;
		ИначеЕсли ИмяТипа = "РегистрРасчета" И Не ПоказыватьРегистрыРасчета Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрДвижения.Пустой И Не ПоказыватьПустыеРегистрыДвижений Тогда
			Продолжить;
		КонецЕсли;
		
		СписокВыбора.Добавить(СтрДвижения.ИмяНабора, СтрДвижения.Представление,, БиблиотекаКартинок[СтрДвижения.ИмяКартинки]);
	КонецЦикла;
	
	РанееВыбранныйНаборДвижений = ВыбранныйНаборДвижений;
	
	ПервыйНаборВСписке = ?(СписокВыбора.Количество() > 0, СписокВыбора[0].Значение, Неопределено);
	
	ВызватьИнициализациюТекущегоНабораДвижений = Ложь;
	
	Если СписокВыбора.НайтиПоЗначению(РанееВыбранныйНаборДвижений) = Неопределено Тогда
		ВыбранныйНаборДвижений = ПервыйНаборВСписке;
		ВызватьИнициализациюТекущегоНабораДвижений = Истина;
	КонецЕсли;
	
	Если ЭтоПеречитываниеОбъекта Тогда
		ВызватьИнициализациюТекущегоНабораДвижений = Истина;
	КонецЕсли;
	
	Если ВызватьИнициализациюТекущегоНабораДвижений Тогда
		ИнициализироватьТаблицуТекущегоНабораДвижений();
	КонецЕсли;
КонецПроцедуры

&НаСервереБезКонтекста
Функция ОбъектСуществует(Ссылка)
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Таблица.Ссылка КАК Ссылка
		|ИЗ
		|	&Таблица КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Таблица", Ссылка.Метаданные().ПолноеИмя());
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	Возврат Не РезультатЗапроса.Пустой();
КонецФункции

// Получает историю ранее выбранных объектов
//
// Возвращаемое значение:
//  Массив - Пустой, либо содержит значения типа ПустаяСсылка
&НаСервереБезКонтекста
Функция ИсторияРедактора()
	ИсходныеДанные = ХранилищеОбщихНастроек.Загрузить("Инструментики.РедакторОбъектов", "История");
	Если ИсходныеДанные = Неопределено Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	Сч = 0;
	Пока Сч < ИсходныеДанные.Количество() Цикл
		Ссылка = ИсходныеДанные[Сч];
		Если ОбъектСуществует(Ссылка) Тогда
			Сч = Сч + 1;
		Иначе
			ИсходныеДанные.Удалить(Сч);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИсходныеДанные;
КонецФункции

//
// Параметры:
//  НоваяСсылка - ЛюбаяСсылка -
&НаСервереБезКонтекста
Процедура ЗаписатьВИсториюРедактора(Знач НоваяСсылка)
	МассивСсылок = ИсторияРедактора();
	МассивСсылок.Вставить(0, НоваяСсылка);
	
	НайденныеСсылки = Новый Массив;
	Сч = 0;
	Пока Сч < МассивСсылок.Количество() Цикл
		Ссылка = МассивСсылок[Сч];
		Если НайденныеСсылки.Найти(Ссылка) = Неопределено Тогда
			НайденныеСсылки.Добавить(Ссылка);
			Сч = Сч + 1;
		Иначе
			МассивСсылок.Удалить(Сч);
		КонецЕсли;
	КонецЦикла;
	
	Пока МассивСсылок.Количество() > 10 Цикл
		МассивСсылок.Удалить(10);
	КонецЦикла;
	
	ХранилищеОбщихНастроек.Сохранить("Инструментики.РедакторОбъектов", "История", МассивСсылок);
КонецПроцедуры

// Если передано значение ссылочного типа, оно будет открыто в редакторе вместо текущего объекта
// Если передано иное значение - будет выведено предупреждение
//
// Параметры:
//  Значение - Произвольный -
&НаКлиенте
Асинх Процедура ОткрытьРеквизитВРедактореАсинх(Значение)
	Если Не ЗначениеЗаполнено(Значение) Тогда
		ПоказатьПредупреждение(, "Это пустое значение");
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Значение) Или Не ОграничениеТипаВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		ПоказатьПредупреждение(, "Данное значение не является значением ссылочного типа");
		Возврат;
	КонецЕсли;
	
	Если Не Ждать ЗапроситьСохранениеАсинх() Тогда
		Возврат;
	КонецЕсли;
	
	Ссылка = Значение;
	ВызватьЧтениеОбъекта();
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция ДатаСозданияСсылки(Знач УникальныйИдентификатор)
	// https://helpf.pro/faq/view/1099.html
	Если Сред(УникальныйИдентификатор, 15, 1) = "4" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
    Строка16 = Сред(УникальныйИдентификатор, 16, 3) + Сред(УникальныйИдентификатор, 10, 4) + Сред(УникальныйИдентификатор, 1, 8);
    Разрядность = СтрДлина(Строка16);
    ЧислоСек = 0;
    Для Позиция = 1 По Разрядность Цикл
        ЧислоСек = ЧислоСек + Найти("123456789abcdef",Сред(Строка16,Позиция,1))*Pow(16,Разрядность - Позиция);
    КонецЦикла;
    ЧислоСек = ЧислоСек / 10000000;
    Возврат Дата(1582, 10, 15, 04, 00, 00) + ЧислоСек;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ИмяМенеджераПоПолномуИмениОбъектаМетаданных(ПолноеИмяОбъектаМетаданных)
	Возврат СтрЗаменить(ПолноеИмяОбъектаМетаданных, ".", "Менеджер.");
КонецФункции

&НаСервереБезКонтекста
Функция СсылкаПоУникальномуИдентификатору(Знач СсылкаДляОпределенияТипа, Знач УникальныйИдентификатор)
	Если СсылкаДляОпределенияТипа <> Неопределено Тогда
		ИмяТипаМенеджера = СтрЗаменить(СсылкаДляОпределенияТипа.Метаданные().ПолноеИмя(), ".", "Менеджер.");
		Менеджер = Новый(ИмяТипаМенеджера);
		Возврат Менеджер.ПолучитьСсылку(УникальныйИдентификатор);
	Иначе
		Запрос = Новый Запрос;
		ЧастиЗапроса = Новый Массив;
		
		КоллекцииМенеджеров = Новый Массив;
		КоллекцииМенеджеров.Добавить(Справочники);
		КоллекцииМенеджеров.Добавить(Документы);
		КоллекцииМенеджеров.Добавить(ПланыВидовХарактеристик);
		КоллекцииМенеджеров.Добавить(ПланыСчетов);
		КоллекцииМенеджеров.Добавить(ПланыВидовРасчета);
		КоллекцииМенеджеров.Добавить(БизнесПроцессы);
		КоллекцииМенеджеров.Добавить(Задачи);
		КоллекцииМенеджеров.Добавить(ПланыОбмена);
		
		Для Каждого КоллекцияМенеджеров Из КоллекцииМенеджеров Цикл
			Для Каждого МенеджерОбъекта Из КоллекцияМенеджеров Цикл
				Ссылка = МенеджерОбъекта.ПолучитьСсылку(УникальныйИдентификатор);
				Если Не ПравоДоступа("Чтение", Ссылка.Метаданные()) Тогда
					Продолжить;
				КонецЕсли;
				
				ПолноеИмяМетаданных = Ссылка.Метаданные().ПолноеИмя();
				
				ИмяПараметра = "Ссылка" + СтрЗаменить(ПолноеИмяМетаданных, ".", "");
				ЧастьЗапроса = СтрШаблон("ВЫБРАТЬ Таблица.Ссылка ИЗ %1 КАК Таблица ГДЕ Таблица.Ссылка = &%2", ПолноеИмяМетаданных, ИмяПараметра);
				ЧастиЗапроса.Добавить(ЧастьЗапроса);
				
				Запрос.УстановитьПараметр(ИмяПараметра, Ссылка);
			КонецЦикла;
		КонецЦикла;
		
		Запрос.Текст = СтрСоединить(ЧастиЗапроса, "
		                                          |ОБЪЕДИНИТЬ ВСЕ
												  |");
		РезультатЗапроса = Запрос.Выполнить();
		Выборка = РезультатЗапроса.Выбрать();
		
		Если Выборка.Количество() = 1 Тогда
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
КонецФункции

&НаСервере
Функция ПутьКДаннымЭлементаФормы(Знач ИмяЭлемента)
	Возврат Элементы.Найти(ИмяЭлемента).ПутьКДанным;
КонецФункции

&НаКлиенте
Асинх Процедура ИзменитьУникальныйИдентификатор(ИзменяемыйОбъект, ИмяИзменяемогоСвойства)
	СтароеЗначение = Строка(ИзменяемыйОбъект[ИмяИзменяемогоСвойства]);
	НовоеЗначениеСтрокой = Ждать ВвестиСтрокуАсинх(СтароеЗначение, НСтр("ru='Введите значение'"), 36);
	Если НовоеЗначениеСтрокой = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		НовоеЗначение = Новый УникальныйИдентификатор(НовоеЗначениеСтрокой);
	Исключение
		ПоказатьПредупреждение(, НСтр("ru='Введенное значение не является уникальным идентификатором'"));
		Возврат;
	КонецПопытки;
	
	ИзменяемыйОбъект[ИмяИзменяемогоСвойства] = НовоеЗначение;
	Модифицированность = Истина;
КонецПроцедуры

#КонецОбласти
