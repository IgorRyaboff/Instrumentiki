
// --------------------------------------------------------------------------------
// Copyright (c) 2025 Igor Ryabov (https://github.com/IgorRyaboff/Instrumentiki)
// License: https://github.com/IgorRyaboff/Instrumentiki/blob/main/LICENSE
// --------------------------------------------------------------------------------

#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	Элементы.ПривилегированныйРежим.Доступность = Не БезопасныйРежим();
	
	ОграничениеТипаВсеСсылки = ОграничениеТипаВсеСсылки();
	Элементы.ЛевоеЗначение.ОграничениеТипа = ОграничениеТипаВсеСсылки;
	Элементы.ПравоеЗначение.ОграничениеТипа = ОграничениеТипаВсеСсылки;
	
	Если Параметры.Ссылки <> Неопределено Тогда
		СсылкаСлева = Параметры.Ссылки[0];
		СсылкаСправа = Параметры.Ссылки[1];
		ПеречитатьОбъектыНаСервере();
	КонецЕсли;
	
	УМ_ПриСозданииНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	УМ_ПриОткрытии();
КонецПроцедуры

&НаКлиенте
Процедура ПередЗакрытием(Отказ, ЗавершениеРаботы, ТекстПредупреждения, СтандартнаяОбработка)
	УМ_ПередЗакрытием(Отказ, ЗавершениеРаботы);
КонецПроцедуры

&НаКлиенте
Процедура ПриЗакрытии(ЗавершениеРаботы)
	УМ_ПриЗакрытии(ЗавершениеРаботы);
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы

#Область УниверсальныеМеханизмы1

#Область КрасивыйРедактор

// Обработчик ДокументСформирован HTML-документов красивого редактора
//  Подключается программно при вызове УМ_КрасивыйРедактор_ПриСозданииНаСервере
//
// Параметры:
//  Элемент - ПолеФормы - HTML-документ
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_СобытиеДокументСформирован(Элемент)
	Редактор = Неопределено;
	Для Каждого РедакторВнутриЦикла Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Если РедакторВнутриЦикла.ИмяЭлементаHTML = Элемент.Имя Тогда
			Редактор = РедакторВнутриЦикла;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Редактор = Неопределено Тогда
		Шаблон = НСтр("ru = 'Не найдено описание красивого редактора для элемента %1';
			|en = 'Did not found HTML editor description for form element %1'");
		ВызватьИсключение СтрШаблон(Шаблон, Элемент.Имя);
	КонецЕсли;
	
	Вью = _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элемент);
	Вью.setContent(ЭтотОбъект[Редактор.ИмяРеквизита]);
	Вью.setOption("generateModificationEvent", Истина);
	Вью.setOption("generateOnKeyDownEvent", Истина);
	Вью.updateMetadata(_УМ_КрасивыйРедактор_СтруктураМетаданных());
	
	// См. https://vk.cc/cs5MzW
	Если Редактор.Язык = "ВстроенныйЯзык" Тогда
		Вью.setLanguageMode("bsl");
	ИначеЕсли Редактор.Язык = "ЯзыкЗапросов" Тогда
		Вью.setLanguageMode("bsl_query");
	Иначе
		ВызватьИсключение НСтр("ru = 'Недопустимый язык редактора';
			|en = 'Invalid editor language'");
	КонецЕсли;
КонецПроцедуры

// Обработчик ПриНажатии HTML-документов красивого редактора
//  Подключается программно при вызове УМ_КрасивыйРедактор_ПриСозданииНаСервере
//
// Параметры:
//  Элемент - ПолеФормы - См. Синтакс-помощник
//  ДанныеСобытия - ФиксированнаяСтруктура - См. Синтакс-помощник
//  СтандартнаяОбработка - Булево - См. Синтакс-помощник
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_СобытиеПриНажатии(Элемент, ДанныеСобытия, СтандартнаяОбработка)
	СобытиеРедактора = ДанныеСобытия.Event.EventData1C;
	Если СобытиеРедактора = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Редактор = Неопределено;
	Для Каждого РедакторВнутриЦикла Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Если РедакторВнутриЦикла.ИмяЭлементаHTML = Элемент.Имя Тогда
			Редактор = РедакторВнутриЦикла;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Редактор = Неопределено Тогда
		Шаблон = НСтр("ru = 'Не найдено описание красивого редактора для элемента %1';
			|en = 'Did not found HTML editor description for form element %1'");
		ВызватьИсключение СтрШаблон(Шаблон, Элемент.Имя);
	КонецЕсли;
	
	Если СобытиеРедактора.event = "EVENT_CONTENT_CHANGED" Тогда
		НовыйТекст = _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элемент).getText();
		Если НовыйТекст <> ЭтотОбъект[Редактор.ИмяРеквизита] Тогда
			ЭтотОбъект[Редактор.ИмяРеквизита] = НовыйТекст;
			Модифицированность = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если СобытиеРедактора.event = "EVENT_ON_KEY_DOWN" Тогда
		Если СобытиеРедактора.params.keyCode = 9 Тогда // ESC
			Закрыть();
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#КонецОбласти

&НаКлиенте
Процедура СсылкаСлеваПриИзменении(Элемент)
	Если ТипЗнч(СсылкаСлева) <> ТипЗнч(СсылкаСправа) Тогда
		СсылкаСправа = Новый(ТипЗнч(СсылкаСлева));
	КонецЕсли;
	
	ПеречитатьОбъектыНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ПравоеЗначениеПриИзменении(Элемент)
	ПеречитатьОбъектыНаСервере();
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

#Область УниверсальныеМеханизмы1

#Область Сохранение

// Обработчик команды открытия сохраненного файла
//
// Параметры:
//  Команда - КомандаФормы - Вызванная команда
//
&НаКлиенте
Асинх Процедура УМ_Сохранение_ОткрытьФайл(Команда)
	Если Не Ждать УМ_Сохранение_ЗапроситьСохранениеАсинх() Тогда
		Возврат;
	КонецЕсли;
	
	АдресВХ = Неопределено;
	Если ЗначениеЗаполнено(ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения) Тогда
		Кнопки = Новый СписокЗначений;
		Кнопки.Добавить(КодВозвратаДиалога.Да, НСтр("ru = 'Открыть сохраненные данные';
			|en = 'Open previously saved data'"));
		Кнопки.Добавить(КодВозвратаДиалога.Нет, НСтр("ru = 'Открыть данные из файла...';
			|en = 'Open a file...'"));
		Кнопки.Добавить(КодВозвратаДиалога.Отмена);
		Ответ = Ждать ВопросАсинх(НСтр("ru = 'Есть сохраненные данные с прошлого сеанса использования инструмента';
			|en = 'There are autosaved data from previous tool usage'"), Кнопки);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			АдресВХ = ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения;
		ИначеЕсли Ответ = КодВозвратаДиалога.Нет Тогда
			ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения = Неопределено;
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(АдресВХ) Тогда
		ПараметрыДиалогаПомещенияФайлов = Новый ПараметрыДиалогаПомещенияФайлов;
		ПараметрыДиалогаПомещенияФайлов.МножественныйВыбор = Ложь;
		ПараметрыДиалогаПомещенияФайлов.Фильтр = НСтр("ru = 'Сохранённые данные Инструментиков (*.xml)|*.xml|Все файлы|*';
			|en = 'Instrumentiki saved data (*.xml)|*.xml|All files|*'");
		
		ОписаниеПомещенногоФайла = Ждать ПоместитьФайлНаСерверАсинх(,,,
			ПараметрыДиалогаПомещенияФайлов, ЭтотОбъект.УникальныйИдентификатор);
		//
		Если ОписаниеПомещенногоФайла = Неопределено Тогда
			Возврат;
		КонецЕсли;
		АдресВХ = ОписаниеПомещенногоФайла.Адрес;
	КонецЕсли;
	
	УМ_Сохранение_ПрочитатьУниверсальныйПакет(АдресВХ);
	УМ_Сохранение_ПослеЧтенияУниверсальногоПакетаПереопределяемый();
КонецПроцедуры

// Обработчик команды сохранения данных инструмента в файл
//
// Параметры:
//  Команда - КомандаФормы - Вызванная команда
//
&НаКлиенте
Процедура УМ_Сохранение_СохранитьФайл(Команда)
	УМ_Сохранение_СохранитьАсинх();
КонецПроцедуры

#КонецОбласти

#КонецОбласти

&НаКлиенте
Процедура ПоменятьЛевоеПравоеМестами(Команда)
	Если Не ЗначениеЗаполнено(СсылкаСлева) И Не ЗначениеЗаполнено(СсылкаСправа) Тогда
		Возврат;
	КонецЕсли;
	
	НовоеЛево = ?(ЗначениеЗаполнено(СсылкаСправа), СсылкаСправа, Новый(ТипЗнч(СсылкаСлева)));
	НовоеПраво = СсылкаСлева;
	
	СсылкаСлева = НовоеЛево;
	СсылкаСправа = НовоеПраво;
	
	ПеречитатьОбъектыНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура УстановитьОтображениеТолькоРазличающихся(Команда)
	ПоказыватьТолькоРазличающиеся = Не ПоказыватьТолькоРазличающиеся;
	Элементы.РеквизитыОбъектовУстановитьОтображениеТолькоРазличающихся.Пометка = ПоказыватьТолькоРазличающиеся;
	
	Отбор = ?(ПоказыватьТолькоРазличающиеся, Новый ФиксированнаяСтруктура("ЗначенияРавны", Ложь), Неопределено);
	Элементы.РеквизитыОбъектов.ОтборСтрок = Отбор;
КонецПроцедуры

&НаКлиенте
Процедура СортироватьВозр(Команда)
	СортироватьТаблицуЗначений("РеквизитыОбъектов", "Возр");
КонецПроцедуры

&НаКлиенте
Процедура СортироватьУбыв(Команда)
	СортироватьТаблицуЗначений("РеквизитыОбъектов", "Убыв");
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьЛевоеЗначениеИзНавигационнойСсылки(Команда)
	ВызватьУстановкуЗначенияИзНавигационнойСсылкиАсинх("СсылкаСлева");
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьПравоеЗначениеИзНавигационнойСсылки(Команда)
	ВызватьУстановкуЗначенияИзНавигационнойСсылкиАсинх("СсылкаСправа");
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьЛевоеЗначениеИзОкна(Команда)
	ВызватьУстановкуЗначенияИзОткрытыхОконАсинх("СсылкаСлева");
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьПравоеЗначениеИзОкна(Команда)
	ВызватьУстановкуЗначенияИзОткрытыхОконАсинх("СсылкаСправа");
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область УниверсальныеМеханизмы1

#Область ОбработчикиСобытийФормы

// Необходимо вызывать внутри обработчика ПриСозданииНаСервере модуля формы
//
&НаСервере
Процедура УМ_ПриСозданииНаСервере()
	Реквизит = Новый РеквизитФормы("УМ_Данные", Новый ОписаниеТипов);
	ДобавляемыеРеквизиты = Новый Массив;
	ДобавляемыеРеквизиты.Добавить(Реквизит);
	ИзменитьРеквизиты(ДобавляемыеРеквизиты);
	ЭтотОбъект.УМ_Данные = Новый Структура;
КонецПроцедуры

// Необходимо вызывать внутри обработчика ПриОткрытии модуля формы
//
&НаКлиенте
Процедура УМ_ПриОткрытии()
	_УМ_КрасивыйРедактор_ПриОткрытии();
КонецПроцедуры

// Необходимо вызывать внутри обработчика ПередЗакрытием модуля формы
//
// Параметры:
//  Отказ - Булево - Параметр из обработчика события формы
//  ЗавершениеРаботы - Булево - Параметр из обработчика события формы
//
&НаКлиенте
Процедура УМ_ПередЗакрытием(Отказ, ЗавершениеРаботы)
	_УМ_Сохранение_ПередЗакрытием(Отказ, ЗавершениеРаботы);
КонецПроцедуры

// Необходимо вызывать внутри обработчика ПриЗакрытии модуля формы
//
// Параметры:
//  ЗавершениеРаботы - Булево - Параметр из обработчика события формы
//
&НаКлиенте
Процедура УМ_ПриЗакрытии(ЗавершениеРаботы)
	_УМ_КрасивыйРедактор_ПриЗакрытии(ЗавершениеРаботы);
КонецПроцедуры

#КонецОбласти

#Область Сохранение

// Необходимо вызывать внутри обработчика ПриСозданииНаСервере модуля формы при использовании механизма "Сохранение"
// Вызов должен размещаться после вызова УМ_ПриСозданииНаСервере
//
&НаСервере
Процедура УМ_Сохранение_ПриСозданииНаСервере()
	ЭтотОбъект.УМ_Данные.Вставить("Сохранение", Новый Структура);
	
	КлючНастроек = "";
	ИмяОбъекта = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(Неопределено, ИмяОбъекта, Неопределено, КлючНастроек);
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	СохраненныеДанные = МодульОбъекта.СохраненнаяНастройка(КлючНастроек, "ДанныеАвтосохранения");
	
	ЭтотОбъект.УМ_Данные.Сохранение.Вставить("АдресДанныхАвтосохранения");
	Если ЗначениеЗаполнено(СохраненныеДанные) Тогда
		АдресВХ = ПоместитьВоВременноеХранилище(СохраненныеДанные, УникальныйИдентификатор);
		
		МодульОбъекта = РеквизитФормыВЗначение("Объект");
		РезультатЧтения = МодульОбъекта.ДанныеИзУниверсальногоПакетаВХ(АдресВХ, ИмяОбъекта);
		
		Если Не РезультатЧтения.Свойство("Ошибка") Тогда
			ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения = АдресВХ;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Загружает данные, ранее сохранённые в этом инструменте
//
// Параметры:
//  Адрес - Строка - Адрес файла во временном хранилище
//
&НаСервере
Процедура УМ_Сохранение_ПрочитатьУниверсальныйПакет(Знач Адрес)
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	
	ВерсияФормата = 0;
	ИмяИнструмента = "";
	ИмяОбъекта = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(ВерсияФормата, ИмяОбъекта,
		ИмяИнструмента, Неопределено);
	//
	
	ДанныеПакета = МодульОбъекта.ДанныеИзУниверсальногоПакетаВХ(Адрес, ИмяОбъекта);
	Если ДанныеПакета.Свойство("Ошибка") Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ДанныеПакета.Ошибка;
		Сообщение.Сообщить();
		Возврат;
	КонецЕсли;
	
	УМ_Сохранение_ПриЧтенииОбъектаПереопределяемый(ДанныеПакета.Объект, ДанныеПакета.ВерсияФормата);
	
	Модифицированность = Ложь;
КонецПроцедуры

// Выполняет автосохранение данных формы
//
&НаСервере
Процедура УМ_Сохранение_ВыполнитьАвтосохранение()
	КлючНастроек = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(Неопределено, Неопределено,
		Неопределено, КлючНастроек);
	//
	
	АдресПакетаВХ = _УМ_Сохранение_СформироватьУниверсальныйПакет();
	ДанныеПакета = ПолучитьИзВременногоХранилища(АдресПакетаВХ);
	УдалитьИзВременногоХранилища(АдресПакетаВХ);
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	МодульОбъекта.СохранитьНастройку(ключНастроек, "ДанныеАвтосохранения", ДанныеПакета);
	ЭтотОбъект.УМ_Данные.Сохранение.АдресДанныхАвтосохранения = Неопределено;
КонецПроцедуры

// Запрашивает сохранение текущих данных
//
// Параметры:
//  ЗакрытьФорму - Булево - Если Истина, форма будет закрыта после сохранения или отказа от сохранения
//
// Возвращаемое значение:
//  Обещание - Результат работы обещания - Булево - Разрешить выполнение действия
//
&НаКлиенте
Асинх Функция УМ_Сохранение_ЗапроситьСохранениеАсинх(ЗакрытьФорму = Ложь)
	Если Не Модифицированность Тогда
		Возврат Истина;
	КонецЕсли;
	
	Ответ = Ждать ВопросАсинх("Данные были изменены. Сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
	Если Ответ = КодВозвратаДиалога.Да Тогда
		Результат = Ждать УМ_Сохранение_СохранитьАсинх();
	ИначеЕсли Ответ = КодВозвратаДиалога.Нет Тогда
		Результат = Истина;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	
	Если Результат И ЗакрытьФорму Тогда
		Модифицированность = Ложь;
		ЭтотОбъект.Закрыть();
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Выполняет сохранение данных
//
// Возвращаемое значение:
//  Обещание - Результат работы обещания - Булево - Данные сохранены
//             Может быть Ложь, если пользователь отменил сохранение в соответствующих диалогах
//
&НаКлиенте
Асинх Функция УМ_Сохранение_СохранитьАсинх()
	ИмяИнструмента = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(Неопределено, Неопределено,
		ИмяИнструмента, Неопределено);
	//
	
	Если Не ПроверитьЗаполнение() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		АдресВХ = _УМ_Сохранение_СформироватьУниверсальныйПакет();
		#Если ВебКлиент Тогда
			Ждать ПолучитьФайлССервераАсинх(АдресВХ, ИмяИнструмента + ".xml", Новый ПараметрыДиалогаПолученияФайлов);
		#Иначе
			Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
			Диалог.Фильтр = "Файл сохраняемых данных (*.xml)|*.xml|Все файлы|*";
			ВыбранныеФайлы = Ждать Диалог.ВыбратьАсинх();
			Если ВыбранныеФайлы = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Ждать ПолучитьФайлССервераАсинх(АдресВХ, ВыбранныеФайлы[0]);
		#КонецЕсли
	Исключение
		ТекстОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Ждать ПредупреждениеАсинх(ТекстОшибки,, НСтр("ru='Ошибка сохранения данных'"));
	КонецПопытки;
	
	Модифицированность = Ложь;
	Возврат Истина;
КонецФункции

// Формирует XML-файл для сохранения текущих данных и помещает его во временное хранилище
//
// Возвращаемое значение:
//  Строка - Адрес во временном хранилище
//
&НаСервере
Функция _УМ_Сохранение_СформироватьУниверсальныйПакет()
	ВерсияФормата = 0;
	ИмяИнструмента = "";
	ИмяОбъекта = "";
	УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(ВерсияФормата, ИмяОбъекта,
		ИмяИнструмента, Неопределено);
	//
	Если ВерсияФормата = 0 Тогда
		ВызватьИсключение "Не определены настройки инструмента XDTO";
	КонецЕсли;
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	Фабрика = МодульОбъекта.ФабрикаXDTO(ВерсияФормата);
	
	ОбъектXDTO = Фабрика.Создать(Фабрика.Тип("instrumentiki", ИмяОбъекта));
	УМ_Сохранение_ПриЗаполненииСохраняемогоОбъектаПереопределяемый(Фабрика, ОбъектXDTO);
	ОбъектXDTO.Проверить();
	
	АдресВХ = МодульОбъекта.ДанныеВУниверсальныйПакетВХ(ВерсияФормата, ОбъектXDTO,
		ИмяИнструмента, ЭтотОбъект.УникальныйИдентификатор);
	//
	Возврат АдресВХ;
КонецФункции

&НаКлиенте
Процедура _УМ_Сохранение_ПередЗакрытием(Отказ, ЗавершениеРаботы)
	Если Не ЭтотОбъект.УМ_Данные.Свойство("Сохранение") Тогда
		Возврат;
	КонецЕсли;
	
	Если Модифицированность Тогда
		Отказ = Истина;
		Если Не ЗавершениеРаботы Тогда
			УМ_Сохранение_ЗапроситьСохранениеАсинх(Истина);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область КрасивыйРедактор

// Необходимо вызывать внутри обработчика ПриСозданииНаСервере модуля формы при использовании
// механизма "КрасивыйРедактор"
// Вызов должен размещаться после вызова УМ_ПриСозданииНаСервере
//
&НаСервере
Процедура УМ_КрасивыйРедактор_ПриСозданииНаСервере()
	ЭтотОбъект.УМ_Данные.Вставить("КрасивыйРедактор", Новый Структура);
	ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Вставить("Используется", Ложь);
	
	Редакторы = Новый Массив;
	УМ_КрасивыйРедактор_ПриОпределенииРедакторовПереопределяемый(Редакторы);
	ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Вставить("Редакторы", Редакторы);
	
	Для Каждого Редактор Из Редакторы Цикл
		Элементы[Редактор.ИмяЭлементаТекстовыйДокумент].Видимость = Истина;
		Элементы[Редактор.ИмяЭлементаHTML].Видимость = Ложь;
		
		Элементы[Редактор.ИмяЭлементаHTML].УстановитьДействие(
			"ДокументСформирован", "УМ_КрасивыйРедактор_СобытиеДокументСформирован");
		Элементы[Редактор.ИмяЭлементаHTML].УстановитьДействие(
			"ПриНажатии", "УМ_КрасивыйРедактор_СобытиеПриНажатии");
	КонецЦикла;
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	МодульОбъекта.ИнициализироватьКрасивыйРедакторКода(УникальныйИдентификатор);
	ЗначениеВРеквизитФормы(МодульОбъекта, "Объект");
КонецПроцедуры

// Переключает редактор кода между текстовым документом и HTML-редактором
//
// Параметры:
//  Кнопка - КнопкаФормы - Кнопка, на которой необходимо отразить новое состояние использования красивого редактора
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_ПереключитьРедакторКода(Кнопка)
	#Если ВебКлиент Тогда
		ПоказатьПредупреждение(, "Красивый редактор кода недоступен в веб-клиенте",, "Ой, у вас веб-клиент");
		Возврат;
	#КонецЕсли
	
	ИспользуетсяКрасивыйРедактор = Не ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Используется;
	ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Используется = ИспользуетсяКрасивыйРедактор;
	
	Для Каждого Редактор Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Элементы[Редактор.ИмяЭлементаТекстовыйДокумент].Видимость = Не ИспользуетсяКрасивыйРедактор;
		Элементы[Редактор.ИмяЭлементаHTML].Видимость = ИспользуетсяКрасивыйРедактор;
		Кнопка.Пометка = ИспользуетсяКрасивыйРедактор;
	КонецЦикла;
КонецПроцедуры

// Обновляет код в HTML-полях красивого редактора
// Может вызываться при программном изменении значения исходного реквизита с кодом
//
&НаКлиенте
Процедура УМ_КрасивыйРедактор_ОбновитьТекст()
	Для Каждого Редактор Из ЭтотОбъект.УМ_Данные.КрасивыйРедактор.Редакторы Цикл
		Вью = _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элементы[Редактор.ИмяЭлементаHTML]);
		Если Вью <> Неопределено Тогда
			Вью.setContent(ЭтотОбъект[Редактор.ИмяРеквизита]);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Функция _УМ_КрасивыйРедактор_ОбъектВьюРедактора(Элемент)
	Возврат ?(Элемент.Документ = Неопределено, Неопределено, Элемент.Документ.defaultView);
КонецФункции

&НаКлиенте
Процедура _УМ_КрасивыйРедактор_ПриОткрытии()
	Если Не ЭтотОбъект.УМ_Данные.Свойство("КрасивыйРедактор") Тогда
		Возврат;
	КонецЕсли;
	
	#Если Не ВебКлиент Тогда
		Если ЭтоАдресВременногоХранилища(Объект.ПутьККрасивомуРедакторуКода) Тогда
			_УМ_КрасивыйРедактор_РаспаковатьРедактор();
		Иначе
			ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь = Объект.ПутьККрасивомуРедакторуКода;
		КонецЕсли;
	#КонецЕсли
КонецПроцедуры

// Получает ZIP-файл из временного хранилища и распаковывает архив во временную директорию
//
&НаКлиенте
Асинх Процедура _УМ_КрасивыйРедактор_РаспаковатьРедактор()
	// BSLLS:MissingTemporaryFileDeletion-off
	// Каталог нужен на весь период, пока открыта форма. Удаляется в обработчике ПриЗакрытии
	Каталог = ПолучитьИмяВременногоФайла() + "\";
	// BSLLS:MissingTemporaryFileDeletion-on
	ПутьКАрхиву = Каталог + "archive.zip";
	
	Ждать СоздатьКаталогАсинх(Каталог);
	Ждать ПолучитьФайлССервераАсинх(Объект.ПутьККрасивомуРедакторуКода, ПутьКАрхиву);
	
	ЧтениеZIP = Новый ЧтениеZipФайла(ПутьКАрхиву);
	ЧтениеZIP.ИзвлечьВсе(Каталог);
	ЧтениеZIP.Закрыть();
	Ждать УдалитьФайлыАсинх(ПутьКАрхиву);
	
	ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь = "file://" + СтрЗаменить(Каталог, "\", "/") + "index.html";
КонецПроцедуры

// См. https://github.com/salexdv/bsl_console/blob/develop/docs/update_metadata.md
//
// Возвращаемое значение:
//  Структура
//
&НаСервереБезКонтекста
Функция _УМ_КрасивыйРедактор_СтруктураМетаданных()
	Результат = Новый Структура;
	
	Результат.Вставить("catalogs",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Справочники));
	//
	Результат.Вставить("documents",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Документы));
	//
	Результат.Вставить("informationregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыСведений));
	//
	Результат.Вставить("accumulationregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыНакопления));
	//
	Результат.Вставить("accountingregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыБухгалтерии));
	//
	Результат.Вставить("calculationregisters",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.РегистрыРасчета));
	//
	Результат.Вставить("dataprocessors",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Обработки));
	//
	Результат.Вставить("reports",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Отчеты));
	//
	Результат.Вставить("enums",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Перечисления));
	//
	Результат.Вставить("chartsofaccounts",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыСчетов));
	//
	Результат.Вставить("businessprocesses",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.БизнесПроцессы));
	//
	Результат.Вставить("tasks",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Задачи));
	//
	Результат.Вставить("exchangeplans",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыОбмена));
	//
	Результат.Вставить("chartsofcharacteristictypes",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыВидовХарактеристик));
	//
	Результат.Вставить("chartsofcalculationtypes",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.ПланыВидовРасчета));
	//
	Результат.Вставить("constants",
		_УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(Метаданные.Константы));
	//
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, Результат);
	
	Возврат Запись.Закрыть();
КонецФункции

// Формирует структуру с именами метаданных для красивого редактора кода
// См. https://github.com/salexdv/bsl_console/blob/develop/docs/update_metadata.md
//
// Параметры:
//  КоллекцияОбъектовМетаданных - КоллекцияОбъектовМетаданных - Коллекция объектов метаданных
//
// Возвращаемое значение:
//  Структура
//
&НаСервереБезКонтекста
Функция _УМ_КрасивыйРедактор_ИменаОбъектовМетаданныхИзКоллекции(КоллекцияОбъектовМетаданных)
	Результат = Новый Структура;
	
	Для Каждого Мета Из КоллекцияОбъектовМетаданных Цикл
		Результат.Вставить(Мета.Имя, Новый Структура);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Процедура _УМ_КрасивыйРедактор_ПриЗакрытии(ЗавершениеРаботы)
	Если Не ЭтотОбъект.УМ_Данные.Свойство("КрасивыйРедактор") Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь)
		И СтрНачинаетсяС(ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь, "file")
		И ЭтоАдресВременногоХранилища(Объект.ПутьККрасивомуРедакторуКода) Тогда
		
		Каталог = СтрЗаменить(ЭтотОбъект.УМ_КрасивыйРедакторКода_Путь, "file://", "");
		
		Разд = СтрРазделить(СтрЗаменить(Каталог, "/", "\"), "\", Ложь);
		Разд.Удалить(Разд.ВГраница());
		Каталог = СтрСоединить(Разд, "\");
		
		УдалитьФайлыАсинх(Каталог);
		
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ПолучениеСсылок

// Запрашивает у пользователя навигационную ссылку и возвращает ссылку на объект ИБ
// При возникновении ошибки разбора ссылки формируется предупреждение
//
// Возвращаемое значение:
//  ЛюбаяСсылка - Полученная ссылка
//  Неопределено - При прерывании действия пользователем
//
&НаКлиенте
Асинх Функция УМ_ПолучениеСсылок_ЗапроситьСсылкуИзНавигационнойАсинх()
	ТекстСсылки = Ждать ВвестиСтрокуАсинх(Неопределено, НСтр("ru='Навигационная ссылка'"));
	Если ТекстСсылки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Ссылка = _УМ_ПолучениеСсылок_СсылкаИзНавигационной(ТекстСсылки);
		Возврат Ссылка;
	Исключение
		Ждать ПредупреждениеАсинх(НСтр("ru='Ошибка получения ссылки'"));
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

// Запрашивает выбор пользователем открытого окна программы и возвращает соответствующую окну ссылку на объект ИБ
// При возникновении ошибки разбора ссылки формируется предупреждение
//
// Возвращаемое значение:
//  ЛюбаяСсылка - Полученная ссылка
//  Неопределено - При прерывании действия пользователем
//
&НаКлиенте
Асинх Функция УМ_ПолучениеСсылок_ЗапроситьСсылкуИзОткрытыхОконАсинх()
	Окна = ПолучитьОкна();
	СписокДляВыбора = Новый СписокЗначений;
	
	Для Каждого ОткрытоеОкно Из Окна Цикл
		Если ОткрытоеОкно.НачальнаяСтраница Тогда
			Продолжить;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ОткрытоеОкно.ПолучитьНавигационнуюСсылку()) Тогда
			Продолжить;
		КонецЕсли;
		
		СписокДляВыбора.Добавить(ОткрытоеОкно.ПолучитьНавигационнуюСсылку(), ОткрытоеОкно.Заголовок);
	КонецЦикла;
	
	Если СписокДляВыбора.Количество() = 0 Тогда
		ПоказатьПредупреждение(, НСтр("ru='Нет доступных для выбора окон'"));
		Возврат Неопределено;
	КонецЕсли;
	
	ВыбранныйЭлемент = Ждать СписокДляВыбора.ВыбратьЭлементАсинх(НСтр("ru='Выберите окно'"));
	Если ВыбранныйЭлемент = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Ссылка = _УМ_ПолучениеСсылок_СсылкаИзНавигационной(ВыбранныйЭлемент.Значение);
		Возврат Ссылка;
	Исключение
		Ждать ПредупреждениеАсинх(НСтр("ru='Ошибка получения ссылки'"));
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

// Формирует ссылку на объект ИБ из навигационной ссылки вида "e1cib/data/Справочник.Контрагенты?ref=<GUID>"
// При невозможности сформировать ссылку вызывает исключение
//
// Параметры:
//  НавигационнаяСсылка - Строка - Навигационная ссылка
//
// Возвращаемое значение:
//  Произвольный - Ссылка на объект ИБ
//
&НаСервереБезКонтекста
Функция _УМ_ПолучениеСсылок_СсылкаИзНавигационной(Знач НавигационнаяСсылка)
	ПерваяТочка = СтрНайти(НавигационнаяСсылка, "e1cib/data/");
    ВтораяТочка = СтрНайти(НавигационнаяСсылка, "?ref=");
    
    ПредставлениеТипа = Сред(НавигационнаяСсылка, ПерваяТочка + 11, ВтораяТочка - ПерваяТочка - 11);
    ШаблонЗначения = ЗначениеВСтрокуВнутр(ПредопределенноеЗначение(ПредставлениеТипа + ".ПустаяСсылка"));
	НулевойИдентификатор = "00000000000000000000000000000000";
    ЗначениеСсылки = СтрЗаменить(ШаблонЗначения, НулевойИдентификатор, Сред(НавигационнаяСсылка, ВтораяТочка + 5));
	Возврат ЗначениеИзСтрокиВнутр(ЗначениеСсылки);
КонецФункции

#КонецОбласти

#КонецОбласти

#Область УниверсальныеМеханизмыПереопределяемый

#Область Сохранение

// BSLLS:TransferringParametersBetweenClientAndServer-off
// Параметры процедуры возвратные

// Процедура, определяющая параметры интеграции инструмента с функциями сохранения данных
//
// Параметры:
//  ВерсияФормата - Число - Версия формата XDTO
//  ИмяОбъекта - Строка - Имя объекта XDTO
//  ИмяИнструмента - Строка - Пользовательское представление названия текущего инструмента
//  КлючНастроек - Строка - Ключ настроек хранилища общих настроек для данных автосохранения
//
&НаСервереБезКонтекста
Процедура УМ_Сохранение_ПриЗаполненииНастроекИнструментаПереопределяемый(ВерсияФормата, ИмяОбъекта,
	ИмяИнструмента, КлючНастроек)
	
	//
	
КонецПроцедуры

// BSLLS:TransferringParametersBetweenClientAndServer-on

// Функция формирования пакета XDTO для сохранения в файл
//
// Параметры:
//  Фабрика - ФабрикаXDTO - Фабрика, инициализированная по XSD-схемам Инструментиков
//  Пакет - ОбъектXDTO - Объект для заполнения
//
&НаСервере
Процедура УМ_Сохранение_ПриЗаполненииСохраняемогоОбъектаПереопределяемый(Фабрика, Пакет)
	//
КонецПроцедуры

// Процедура чтения данных из файла
//
// Параметры:
//  Пакет - ОбъектXDTO - Объект для заполнения
//  ВерсияФормата - Число - Версия формата XDTO
//
&НаСервере
Процедура УМ_Сохранение_ПриЧтенииОбъектаПереопределяемый(Пакет, ВерсияФормата)
	//
КонецПроцедуры

// Позволяет выполнить произвольные действия на клиенте после успешной загрузки данных инструмента из файла
//
&НаКлиенте
Процедура УМ_Сохранение_ПослеЧтенияУниверсальногоПакетаПереопределяемый()
	//
КонецПроцедуры

#КонецОбласти

#Область КрасивыйРедактор

// Определяет используемые красивые редакторы кода
//
// Параметры:
//  Редакторы - Массив - Массив структур со следующими свойствами:
//  * ИмяРеквизита - Строка - Имя реквизита формы, хранящего код
//  * ИмяЭлементаТекстовыйДокумент - Строка - Имя элемента формы с текстовым документом редактора кода
//  * ИмяЭлементаHTML - Строка - Имя элемента формы, содержащего связанный HTML-документ
//  * Язык - Строка - Редактируемый язык:
//           "ВстроенныйЯзык" - встроенный язык 1С
//           "ЯзыкЗапросов" - язык запросов 1С
//
&НаСервере
Процедура УМ_КрасивыйРедактор_ПриОпределенииРедакторовПереопределяемый(Редакторы)
	//
КонецПроцедуры

#КонецОбласти

#КонецОбласти

&НаКлиенте
Асинх Процедура ВызватьУстановкуЗначенияИзНавигационнойСсылкиАсинх(ИмяРеквизита)
	НоваяСсылка = Ждать УМ_ПолучениеСсылок_ЗапроситьСсылкуИзНавигационнойАсинх();
	Если НоваяСсылка <> Неопределено Тогда
		ЭтотОбъект[ИмяРеквизита] = НоваяСсылка;
		ПеречитатьОбъектыНаСервере();
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Асинх Процедура ВызватьУстановкуЗначенияИзОткрытыхОконАсинх(ИмяРеквизита)
	НоваяСсылка = Ждать УМ_ПолучениеСсылок_ЗапроситьСсылкуИзОткрытыхОконАсинх();
	Если НоваяСсылка <> Неопределено Тогда
		ЭтотОбъект[ИмяРеквизита] = НоваяСсылка;
		ПеречитатьОбъектыНаСервере();
	КонецЕсли;
КонецПроцедуры

// Перечитать оба объекта и перезаполнить данные формы
//
&НаСервере
Процедура ПеречитатьОбъектыНаСервере()
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	РеквизитыОбъектов.Очистить();
	Если Не ЗначениеЗаполнено(СсылкаСлева) Тогда
		Возврат;
	КонецЕсли;
	
	Мета = СсылкаСлева.Метаданные();
	ЛевыйОбъект = СсылкаСлева.ПолучитьОбъект();
	Если ЗначениеЗаполнено(СсылкаСправа) Тогда
		ПравыйОбъект = СсылкаСправа.ПолучитьОбъект();
	Иначе
		ПравыйОбъект = Неопределено;
	КонецЕсли;
	
	Для Каждого Рекв Из ВсеРеквизитыОбъектаМетаданных(Мета, "СтандартныеРеквизиты, Реквизиты") Цикл
		Стр = РеквизитыОбъектов.Добавить();
		Стр.Имя = Рекв.Имя;
		Стр.ОписаниеТипов = Строка(Рекв.Тип);
		Стр.Синоним = Рекв.Синоним;
		ЗначениеСлева = ЛевыйОбъект[Рекв.Имя];
		Стр.ТипСлева = Строка(ТипЗнч(ЗначениеСлева));
		Стр.ЗначениеСлева = ЗначениеСлева;
		
		Если ЗначениеЗаполнено(СсылкаСправа) Тогда
			ЗначениеСправа = ПравыйОбъект[Рекв.Имя];
			Стр.ТипСправа = Строка(ТипЗнч(ЗначениеСправа));
			Стр.ЗначениеСправа = ЗначениеСправа;
			
			Если ТипЗнч(ЗначениеСлева) = ТипЗнч(ЗначениеСправа) Тогда
				Если ТипЗнч(ЗначениеСлева) = Тип("ХранилищеЗначения") Тогда
					Стр.ЗначенияРавны = (XMLСтрока(ЗначениеСлева) = XMLСтрока(ЗначениеСправа));
				Иначе
					Стр.ЗначенияРавны = (ЗначениеСлева = ЗначениеСправа);
				КонецЕсли;
			Иначе
				Стр.ЗначенияРавны = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Получить список всех реквизитов объекта метаданных, включая стандартные
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных -
//  ИменаКоллекцийРеквизитов - Строка - Перечисленные через запятую имена свойств, являющихся коллекциями реквизитов. Например, "СтандартныеРеквизиты, Реквизиты"
//
// Возвращаемое значение:
//  Массив - Массив значений типа ОбъектМетаданных (реквизит)
&НаСервереБезКонтекста
Функция ВсеРеквизитыОбъектаМетаданных(ОбъектМетаданных, ИменаКоллекцийРеквизитов)
	Результат = Новый Массив;
	
	Для Каждого ИмяКоллекции Из СтрРазделить(ИменаКоллекцийРеквизитов, ",") Цикл
		Для Каждого Реквизит Из ОбъектМетаданных[СокрЛП(ИмяКоллекции)] Цикл
			Если ИмяКоллекции = "СтандартныеРеквизиты" И (Реквизит.Имя = "Ссылка" Или Реквизит.Имя = "Регистратор") Тогда
				Продолжить;
			КонецЕсли;
			Результат.Добавить(Реквизит);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Формирует ОписаниеТипов, содержащее все типы всех ссылочных объектов, которые можно создавать в режиме Предприятия
// Необходимо для включения типов из расширений в ограничение типа
//
// Возвращаемое значение:
//  ОписаниеТипов
&НаСервереБезКонтекста
Функция ОграничениеТипаВсеСсылки()
	ОграничениеТипа = Новый ОписаниеТипов;
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Метаданные.Справочники, "СправочникСсылка");
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Метаданные.Документы, "ДокументСсылка");
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Метаданные.ПланыВидовХарактеристик, "ПланВидовХарактеристикСсылка");
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Метаданные.ПланыВидовРасчета, "ПланВидовРасчетаСсылка");
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Метаданные.БизнесПроцессы, "БизнесПроцессСсылка");
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Метаданные.Задачи, "ЗадачаСсылка");
	ОграничениеТипа = ОписаниеТиповКоллекцииОбъектовМетаданных(ОграничениеТипа, Метаданные.ПланыОбмена, "ПланОбменаСсылка");
	Возврат ОграничениеТипа;
КонецФункции

// Добавляет в ИсходноеОписаниеТипов все типы из коллекции Коллекция
//
// Параметры:
//  ИсходноеОписаниеТипов - ОписаниеТипов -
//  Коллекция - КоллекцияОбъектовМетаданных -
//  Префикс - Строка - Префикс для имени типа. Например, для справочников следует передать "СправочникСсылка"
//
// Возвращаемое значение:
//  ОписаниеТипов -
&НаСервереБезКонтекста
Функция ОписаниеТиповКоллекцииОбъектовМетаданных(ИсходноеОписаниеТипов, Коллекция, Префикс)
	ДобавляемыеТипы = Новый Массив;
	Для Каждого Объект Из Коллекция Цикл
		ДобавляемыеТипы.Добавить(СтрШаблон("%1.%2", Префикс, Объект.Имя));
	КонецЦикла;
	
	Результат = Новый ОписаниеТипов(ИсходноеОписаниеТипов, СтрСоединить(ДобавляемыеТипы, ", "));
	Возврат Результат;
КонецФункции

// Универсальная процедура сортировки таблицы значений
//
// Параметры:
//  ИмяТаблицыФормы - Строка - Имя элемента формы, ссылающегося на таблицу
//  Направление - Строка - "Возр" или "Убыв"
&НаСервере
Процедура СортироватьТаблицуЗначений(ИмяТаблицыФормы, Направление)
	ТаблицаФормы = Элементы[ИмяТаблицыФормы];
	ПрефиксПутиКДанным = ТаблицаФормы.ПутьКДанным + ".";
	
	ТекущаяКолонка = ТаблицаФормы.ТекущийЭлемент;
	ИмяКолонки = СтрЗаменить(ТекущаяКолонка.ПутьКДанным, ПрефиксПутиКДанным, "");
	
	ЭтотОбъект[ТаблицаФормы.ПутьКДанным].Сортировать(ИмяКолонки + " " + Направление);
КонецПроцедуры

#КонецОбласти
