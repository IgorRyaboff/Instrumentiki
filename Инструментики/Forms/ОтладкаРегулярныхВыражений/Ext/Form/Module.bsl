
// --------------------------------------------------------------------------------
// Copyright (c) 2024 Igor Ryabov (https://github.com/IgorRyaboff/Instrumentiki)
// License: https://github.com/IgorRyaboff/Instrumentiki/blob/main/LICENSE
// --------------------------------------------------------------------------------

#Область ОписаниеПеременных

#КонецОбласти

#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	СистемнаяИнформация = Новый СистемнаяИнформация;
	НаСервереWindows = СтрНачинаетсяС(Строка(СистемнаяИнформация.ТипПлатформы), "Windows");
	ИгнорироватьРегистр = Истина;
	
	Если Объект.ВерсияПлатформы >= 3.23 Тогда
		Вариант = "8.3.23";
	Иначе
		Вариант = "XDTO";
	КонецЕсли;
	РанееВыбранныйВариант = Вариант;
	
	Выражение = "(\+)?([- ()]?\d[- _():=+]?){10,14}";
	
	Стр = ПроверяемыеСтроки.Добавить();
	Стр.Значение = "+7(495)999 99-99";
	
	Стр = ПроверяемыеСтроки.Добавить();
	Стр.Значение = "1С крута";
	
	ОбработатьРегулярноеВыражение();
	
	#Область СохранениеДанных1
	ЗагрузитьДанныеАвтосохранения();
	#КонецОбласти
КонецПроцедуры

&НаКлиенте
Процедура ПередЗакрытием(Отказ, ЗавершениеРаботы, ТекстПредупреждения, СтандартнаяОбработка)
	#Область СохранениеДанных1
	Если Модифицированность Тогда
		Отказ = Истина;
		Если Не ЗавершениеРаботы Тогда
			ЗапроситьСохранениеАсинх(Истина);
		КонецЕсли;
	КонецЕсли;
	#КонецОбласти
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы

&НаКлиенте
Процедура ВыражениеПриИзменении(Элемент)
	ОбработатьРегулярноеВыражение();
КонецПроцедуры

&НаКлиенте
Процедура ВариантПриИзменении(Элемент)
	Если Вариант = "8.3.23" И Объект.ВерсияПлатформы < 3.23 Тогда
		Вариант = РанееВыбранныйВариант;
		ПоказатьПредупреждение(, "Для использования данного варианта требуется платформа версии 8.3.23 или выше",, "Старая платформа");
		Возврат;
	ИначеЕсли Вариант = "ВнешняяКомпонента" И Не НаСервереWindows Тогда
		Вариант = РанееВыбранныйВариант;
		ПоказатьПредупреждение(, "Данный вариант поддерживается только на серверах, запущенных под управлением Windows",, "Ой, у вас Linux");
		Возврат;
	КонецЕсли;
	
	РанееВыбранныйВариант = Вариант;
	ОбработатьРегулярноеВыражение();
КонецПроцедуры

&НаКлиенте
Процедура ИгнорироватьРегистрПриИзменении(Элемент)
	ОбработатьРегулярноеВыражение();
КонецПроцедуры

&НаКлиенте
Процедура ПодзаголовокФормыПриИзменении(Элемент)
	Если ЗначениеЗаполнено(ПодзаголовокФормы) Тогда
		Заголовок = СтрШаблон(НСтр("ru='%1: Отладка регулярных выражений'"), ПодзаголовокФормы);
	Иначе
		Заголовок = НСтр("ru='Отладка регулярных выражений'");
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормыПроверяемыеСтроки

&НаКлиенте
Процедура ПроверяемыеСтрокиПриИзменении(Элемент)
	ОбработатьРегулярноеВыражение();
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

#Область СохранениеДанных1

&НаКлиенте
Асинх Процедура СохранениеДанных_ОткрытьФайл(Команда)
	Если Объект.БезопасныйРежим Тогда
		ПоказатьПредупреждение(, "Загрузка и сохранение данных недоступны в безопасном режиме",, "Безопасный режим");
		Возврат;
	КонецЕсли;
	
	Если Не Ждать ЗапроситьСохранениеАсинх() Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(АдресДанныхАвтосохранения) Тогда
		Кнопки = Новый СписокЗначений;
		Кнопки.Добавить(КодВозвратаДиалога.Да, "Открыть сохраненные данные");
		Кнопки.Добавить(КодВозвратаДиалога.Нет, "Открыть данные из файла");
		Ответ = Ждать ВопросАсинх("Есть сохраненные данные с прошлого сеанса использования инструмента", Кнопки);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			АдресДанныхАвтосохранения = Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(АдресДанныхАвтосохранения) Тогда
		АдресВХ = АдресДанныхАвтосохранения;
	Иначе
		ПараметрыДиалогаПомещенияФайлов = Новый ПараметрыДиалогаПомещенияФайлов;
		ПараметрыДиалогаПомещенияФайлов.МножественныйВыбор = Ложь;
		ПараметрыДиалогаПомещенияФайлов.Фильтр = "Сохранённые данные Инструментиков (*.xml)|*.xml";
		
		ОписаниеПомещенногоФайла = Ждать ПоместитьФайлНаСерверАсинх(,,, ПараметрыДиалогаПомещенияФайлов, ЭтотОбъект.УникальныйИдентификатор);
		Если ОписаниеПомещенногоФайла = Неопределено Тогда
			Возврат;
		КонецЕсли;
		АдресВХ = ОписаниеПомещенногоФайла.Адрес;
	КонецЕсли;
	
	ПрочитатьУниверсальныйПакет(АдресВХ);
КонецПроцедуры

&НаКлиенте
Процедура СохранениеДанных_СохранитьФайл(Команда)
	СохранитьАсинх();
КонецПроцедуры

#КонецОбласти

&НаКлиенте
Процедура ПоказатьПодсказкуИспользованияВКоде(Команда)
	Если Вариант = "8.3.23" Тогда
		Текст = "См. описание функции ""СтрПодобнаПоРегулярномуВыражению()"" в синтакс-помощнике";
	ИначеЕсли Вариант = "XDTO" Тогда
		Текст = "См. функцию СтрПодобнаПоРегулярномуВыражениюXDTO() формы ОтладкаРегулярныхВыражений";
	ИначеЕсли Вариант = "ВнешняяКомпонента" Тогда
		Текст = "См. функцию СтрПодобнаПоРегулярномуВыражениюVBS() формы ОтладкаРегулярныхВыражений";
	Иначе
		ВызватьИсключение "Некорректный вариант " + Вариант;
	КонецЕсли;
	
	ПоказатьПредупреждение(, Текст);
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции
#Область СохранениеДанных1

// Формирует XML-файл для сохранения текущих данных и помещает его во временное хранилище
//
// Возвращаемое значение:
//  Строка - Адрес во временном хранилище
&НаСервере
Функция СформироватьУниверсальныйПакет()
	ВерсияФормата = 0;
	ИмяИнструмента = "";
	ИмяОбъекта = "";
	ПриОпределенииНастроекИнструментаXDTO(ВерсияФормата, ИмяОбъекта, ИмяИнструмента, Неопределено);
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	Фабрика = МодульОбъекта.ФабрикаXDTO(ВерсияФормата);
	
	ОбъектХДТО = Фабрика.Создать(Фабрика.Тип("instrumentiki", ИмяОбъекта));
	ПриЗаполненииПакетаXDTO(Фабрика, ОбъектХДТО);
	ОбъектХДТО.Проверить();
	
	АдресВХ = МодульОбъекта.ДанныеВУниверсальныйПакетВХ(ВерсияФормата, ОбъектХДТО, ИмяИнструмента, ЭтотОбъект.УникальныйИдентификатор);
	Возврат АдресВХ;
КонецФункции

// Загружает данные, ранее сохранённые в этом инструменте
//
// Параметры:
//  Адрес - Строка - Адрес файла во временном хранилище
&НаСервере
Процедура ПрочитатьУниверсальныйПакет(Адрес)
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	
	ВерсияФормата = 0;
	ИмяИнструмента = "";
	ИмяОбъекта = "";
	ПриОпределенииНастроекИнструментаXDTO(ВерсияФормата, ИмяОбъекта, ИмяИнструмента, Неопределено);
	
	ДанныеПакета = МодульОбъекта.ДанныеИзУниверсальногоПакетаВХ(Адрес, ИмяОбъекта);
	Если ДанныеПакета.Свойство("Ошибка") Тогда
		Сообщить(ДанныеПакета.Ошибка);
		Возврат;
	КонецЕсли;
	
	ПриЧтенииПакетаXDTO(ДанныеПакета.Объект, ДанныеПакета.ВерсияФормата);
	
	Модифицированность = Ложь;
КонецПроцедуры

&НаСервере
Процедура ЗагрузитьДанныеАвтосохранения()
	КлючНастроек = "";
	ИмяОбъекта = "";
	ПриОпределенииНастроекИнструментаXDTO(Неопределено, ИмяОбъекта, Неопределено, КлючНастроек);
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	СохраненныеДанные = МодульОбъекта.СохраненнаяНастройка(КлючНастроек, "ДанныеАвтосохранения");
	
	Если ЗначениеЗаполнено(СохраненныеДанные) Тогда
		АдресВХ = ПоместитьВоВременноеХранилище(СохраненныеДанные, УникальныйИдентификатор);
		
		МодульОбъекта = РеквизитФормыВЗначение("Объект");
		РезультатЧтения = МодульОбъекта.ДанныеИзУниверсальногоПакетаВХ(АдресВХ, ИмяОбъекта);
		
		Если Не РезультатЧтения.Свойство("Ошибка") Тогда
			АдресДанныхАвтосохранения = АдресВХ;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура ВыполнитьАвтосохранение()
	КлючНастроек = "";
	ПриОпределенииНастроекИнструментаXDTO(Неопределено, Неопределено, Неопределено, КлючНастроек);
	
	АдресПакетаВХ = СформироватьУниверсальныйПакет();
	ДанныеПакета = ПолучитьИзВременногоХранилища(АдресПакетаВХ);
	УдалитьИзВременногоХранилища(АдресПакетаВХ);
	
	МодульОбъекта = РеквизитФормыВЗначение("Объект");
	МодульОбъекта.СохранитьНастройку(ключНастроек, "ДанныеАвтосохранения", ДанныеПакета);
	АдресДанныхАвтосохранения = Неопределено;
КонецПроцедуры

// Запрашивает сохранение текущих данных
//
// Параметры:
//  ЗакрытьФорму - Булево - Если Истина, форма будет закрыта после сохранения или отказа от сохранения
//
// Возвращаемое значение:
//  Булево - Разрешить выполнение действия
&НаКлиенте
Асинх Функция ЗапроситьСохранениеАсинх(ЗакрытьФорму = Ложь)
	Если Не Модифицированность Тогда
		Возврат Истина;
	КонецЕсли;
	
	Ответ = Ждать ВопросАсинх("Данные были изменены. Сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
	Если Ответ = КодВозвратаДиалога.Да Тогда
		Результат = Ждать СохранитьАсинх();
	ИначеЕсли Ответ = КодВозвратаДиалога.Нет Тогда
		Результат = Истина;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	
	Если Результат И ЗакрытьФорму Тогда
		Модифицированность = Ложь;
		ЭтотОбъект.Закрыть();
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Выполняет сохранение данных
//
// Возвращаемое значение:
//  Булево - Данные сохранены. Может быть Ложь, если пользователь отменил сохранение в соответствующих диалогах
&НаКлиенте
Асинх Функция СохранитьАсинх()
	Если Объект.БезопасныйРежим Тогда
		ПоказатьПредупреждение(, "Загрузка и сохранение данных недоступны в безопасном режиме",, "Безопасный режим");
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПроверитьЗаполнение() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		АдресВХ = СформироватьУниверсальныйПакет();
		#Если ВебКлиент Тогда
			Ждать ПолучитьФайлССервераАсинх(АдресВХ, "Запрос.xml", Новый ПараметрыДиалогаПолученияФайлов);
		#Иначе
			Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
			Диалог.Фильтр = "Файл сохраняемых данных (*.xml)|*.xml";
			ВыбранныеФайлы = Ждать Диалог.ВыбратьАсинх();
			Если ВыбранныеФайлы = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Ждать ПолучитьФайлССервераАсинх(АдресВХ, ВыбранныеФайлы[0]);
		#КонецЕсли
	Исключение
		Ждать ПредупреждениеАсинх(ОписаниеОшибки(),, "Ошибка сохранения данных");
	КонецПопытки;
	
	Модифицированность = Ложь;
	Возврат Истина;
КонецФункции

#КонецОбласти

// Процедура, определяющая параметры интеграции инструмента с функциями сохранения данных
//
// Параметры:
//  ВерсияФормата - Число -
//  ИмяОбъекта - Строка - Имя объекта XDTO
//  ИмяИнструмента - Строка - Пользовательское представление названия текущего инструмента
//  КлючНастроек - Строка - Ключ настроек хранилища общих настроек для данных автосохранения
&НаСервереБезКонтекста
Процедура ПриОпределенииНастроекИнструментаXDTO(ВерсияФормата, ИмяОбъекта, ИмяИнструмента, КлючНастроек)
	ВерсияФормата = 4;
	ИмяОбъекта = "ОтладкаРегулярныхВыражений_Данные";
	ИмяИнструмента = НСтр("ru='Отладка регулярных выражений'");
	КлючНастроек = "ОтладкаРегулярныхВыражений";
КонецПроцедуры

// Функция формирования пакета XDTO для сохранения в файл
//
// Параметры:
//  Фабрика - ФабрикаXDTO -
//  Пакет - ОбъектXDTO -
//
// Возвращаемое значение:
//  ОбъектXDTO -
&НаСервере
Процедура ПриЗаполненииПакетаXDTO(Фабрика, Пакет)
	Пакет.Выражение = Выражение;
	Пакет.ИгнорироватьРегистр = ИгнорироватьРегистр;
	
	Для Каждого Стр Из ПроверяемыеСтроки Цикл
		Пакет.ПроверяемыеСтроки.Добавить(Стр.Значение);
	КонецЦикла;
КонецПроцедуры

// Процедура чтения данных из файла
//
// Параметры:
//  Пакет - ОбъектXDTO -
//  ВерсияФормата - Число -
&НаСервере
Процедура ПриЧтенииПакетаXDTO(Пакет, ВерсияФормата)
	Выражение = Пакет.Выражение;
	Если ВерсияФормата = 4 Тогда
		ИгнорироватьРегистр = Пакет.ИгнорироватьРегистр;
	Иначе
		ИгнорироватьРегистр = Ложь;
	КонецЕсли;
	
	ПроверяемыеСтроки.Очистить();
	Для Каждого Значение Из Пакет.ПроверяемыеСтроки Цикл
		Стр = ПроверяемыеСтроки.Добавить();
		Стр.Значение = Значение;
	КонецЦикла;
	
	ОбработатьРегулярноеВыражение();
КонецПроцедуры

// Проверяет корректность регулярного выражения, а также обрабатывает строки таблицы ПроверяемыеСтроки
//
&НаСервере
Процедура ОбработатьРегулярноеВыражение()
	Для Каждого Стр Из ПроверяемыеСтроки Цикл
		Стр.ПодобнаПоРегулярномуВыражению = Ложь;
	КонецЦикла;
	
	Для Каждого Стр Из ПроверяемыеСтроки Цикл
		Стр.НайденныеПодстроки.Очистить();
		
		Попытка
			Если Вариант = "8.3.23" Тогда
				Стр.ПодобнаПоРегулярномуВыражению = Вычислить("СтрПодобнаПоРегулярномуВыражению(Стр.Значение, Выражение)");
				
				РезультатыПоиска = Вычислить("СтрНайтиВсеПоРегулярномуВыражению(Стр.Значение, Выражение, ИгнорироватьРегистр)");
				Для Каждого РезультатПоиска Из РезультатыПоиска Цикл
					Стр.НайденныеПодстроки.Добавить(РезультатПоиска.Значение);
				КонецЦикла;
			ИначеЕсли Вариант = "XDTO" Тогда
				Стр.ПодобнаПоРегулярномуВыражению = СтрПодобнаПоРегулярномуВыражениюXDTO(Стр.Значение, Выражение);
			ИначеЕсли Вариант = "ВнешняяКомпонента" Тогда
				РезультатОбработки = ОбработатьСтрокуРегулярнымВыражениемVBScript(Стр.Значение, Выражение, ИгнорироватьРегистр);
				Стр.ПодобнаПоРегулярномуВыражению = РезультатОбработки.Подобна;
				Стр.НайденныеПодстроки.ЗагрузитьЗначения(РезультатОбработки.НайденныеПодстроки);
			Иначе
				ВызватьИсключение "Некорректный вариант " + Вариант;
			КонецЕсли;
		Исключение
			ВыражениеКорректно = Ложь;
			Возврат;
		КонецПопытки;
		
		Стр.НайденоПодстрок = Стр.НайденныеПодстроки.Количество();
	КонецЦикла; 
	
	ВыражениеКорректно = Истина;
	
	УстановитьОтображениеСпискаПодстрок(ЭтотОбъект);
КонецПроцедуры

// Сравнивает две версии
//
// Параметры
//  ВерсияСлева - Строка -
//  ВерсияСправа - Строка -
//
// Возвращаемое значение:
//  Число - "0", если версии совпадают; "1", если ВерсияСлева > ВерсияСправа; "-1", если ВерсияСлева < ВерсияСправа
&НаКлиентеНаСервереБезКонтекста
Функция СравнитьВерсии(ВерсияСлева, ВерсияСправа)
	ЧастиСлева = СтрРазделить(ВерсияСлева, ".");
	ЧастиСправа = СтрРазделить(ВерсияСправа, ".");
	КоличествоЧастей = ?(ЧастиСлева.Количество() > ЧастиСправа.Количество(), ЧастиСлева.Количество(), ЧастиСправа.Количество());
	
	Пока ЧастиСлева.Количество() < КоличествоЧастей Цикл
		ЧастиСлева.Добавить("0");
	КонецЦикла;
	Пока ЧастиСправа.Количество() < КоличествоЧастей Цикл
		ЧастиСправа.Добавить("0");
	КонецЦикла;
	
	Для Сч = 0 По КоличествоЧастей - 1 Цикл
		Слева = Число(ЧастиСлева[Сч]);
		Справа = Число(ЧастиСправа[Сч]);
		
		Если Слева > Справа Тогда
			Возврат -1;
		ИначеЕсли Слева < Справа Тогда
			Возврат 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
КонецФункции

// Проверяет подобность строки по регулярному выражению, используя функционал XDTO
//
// Параметры:
//  ПроверяемаяСтрока - Строка -
//  РегулярноеВыражение - Строка -
//
// Возвращаемое значение:
//  Булево -
&НаСервереБезКонтекста
Функция СтрПодобнаПоРегулярномуВыражениюXDTO(ПроверяемаяСтрока, РегулярноеВыражение)
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + РегулярноеВыражение + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Тест = МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));

    Попытка
        Тест.TestItem = ПроверяемаяСтрока;
        Возврат Истина;
    Исключение
        Возврат Ложь;
    КонецПопытки;
КонецФункции

// Проверяет подобность строки по регулярному выражению, используя компоненту VBScript.RegExp
//
// Параметры:
//  ПроверяемаяСтрока - Строка -
//  РегулярноеВыражение - Строка -
//  ИгнорироватьРегистр - Булево -
//
// Возвращаемое значение:
//  Структура:
//  * Подобна - Булево - Строка полностью подобна выражению
//  * НайденныеПодстроки - Массив - Массив найденных по выражению подстрок
&НаСервереБезКонтекста
Функция ОбработатьСтрокуРегулярнымВыражениемVBScript(ПроверяемаяСтрока, РегулярноеВыражение, ИгнорироватьРегистр)
	ВыражениеПроверкиПодобия = РегулярноеВыражение;
	Если Не СтрНачинаетсяС(ВыражениеПроверкиПодобия, "^") Тогда
		ВыражениеПроверкиПодобия = "^" + ВыражениеПроверкиПодобия;
	КонецЕсли;
	Если Не СтрЗаканчиваетсяНа(ВыражениеПроверкиПодобия, "$") Тогда
		ВыражениеПроверкиПодобия = ВыражениеПроверкиПодобия + "$";
	КонецЕсли;
	
	RegExp = Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine = Ложь;
	RegExp.Global = Ложь;
	RegExp.IgnoreCase = ИгнорироватьРегистр;
	RegExp.Pattern = ВыражениеПроверкиПодобия;
	
	Результат = Новый Структура("Подобна, НайденныеПодстроки", Ложь, Новый Массив);

	Результат.Подобна = RegExp.Test(ПроверяемаяСтрока);
	
	RegExp.Global = Истина;
	RegExp.Pattern = РегулярноеВыражение;
	
	Для Каждого РезультатПоиска Из RegExp.Execute(ПроверяемаяСтрока) Цикл
		Результат.НайденныеПодстроки.Добавить(РезультатПоиска.Value);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Процедура УстановитьОтображениеСпискаПодстрок(Форма)
	Если Форма.Вариант = "XDTO" Тогда
		Форма.Элементы.СтраницыПодстроки.ТекущаяСтраница = Форма.Элементы.СтраницаПодстрокиНедоступны;
	Иначе
		Форма.Элементы.СтраницыПодстроки.ТекущаяСтраница = Форма.Элементы.СтраницаПодстроки;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти
